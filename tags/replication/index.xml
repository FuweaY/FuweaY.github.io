<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Replication on FuweaY</title><link>https://FuweaY.github.io/tags/replication/</link><description>Recent content in Replication on FuweaY</description><generator>Hugo -- gohugo.io</generator><language>zh-tw</language><lastBuildDate>Mon, 07 Apr 2025 12:00:00 +0800</lastBuildDate><atom:link href="https://FuweaY.github.io/tags/replication/index.xml" rel="self" type="application/rss+xml"/><item><title>並行複製 (Multi-Thread Slave, MTS)</title><link>https://FuweaY.github.io/p/mysql-mts/</link><pubDate>Mon, 07 Apr 2025 12:00:00 +0800</pubDate><guid>https://FuweaY.github.io/p/mysql-mts/</guid><description>&lt;h2 id="並行複製-multi-thread-slave-mts">並行複製 (Multi-Thread Slave, MTS)
&lt;/h2>&lt;p>在 MySQL 8.0.27 之前，Replica 預設只有一個 IO_THREAD 和一個 SQL_THREAD：&lt;/p>
&lt;ul>
&lt;li>IO_THREAD 負責從 Source 接收 binlog 並寫入 Replica 的 relaylog&lt;/li>
&lt;li>SQL_THREAD 負責解析和重放 relaylog 中的 event&lt;/li>
&lt;/ul>
&lt;p>當 Source 有併發大量寫入時，Replica 的 IO_THREAD 因為是順序寫入一般不會導致 replication delay，但是只有單線程 SQL_THREAD 回放速度是跟不上有多線程寫入的 Source，因此會造成 replication delay 不斷變大，相應也導致 Replica 的 relaylog 大量堆積占滿 disk 空間。&lt;/p>
&lt;p>因此從 MySQL 5.6 開始提供了 Multi-Tread Slave (MTS)，透過多線程的 SQL_THREAD 來緩解這種問題，並且在後續的大版本中不斷進行優化。&lt;/p>
&lt;h2 id="各個版本的-mts">各個版本的 MTS
&lt;/h2>&lt;h3 id="基於-database-級別的-mts-56">基於 database 級別的 MTS (5.6)
&lt;/h3>&lt;p>在 MySQL 5.6 只有基於 Database 級別的 MTS，只有在不同 Database 的語句才可以並行執行，因此這無法解決單表高寫入所造成的同步延遲。&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/MySQL-56-MTS-ByDatabase.png"
width="808"
height="209"
srcset="https://FuweaY.github.io/p/mysql-mts/MySQL-56-MTS-ByDatabase_hu_76640f19593a5e88.png 480w, https://FuweaY.github.io/p/mysql-mts/MySQL-56-MTS-ByDatabase_hu_1cab929c3ba48.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="386"
data-flex-basis="927px"
>&lt;/p>
&lt;h3 id="基於-group-commit-的-mts-57">基於 Group Commit 的 MTS (5.7)
&lt;/h3>&lt;h4 id="group-commit-簡述">Group Commit 簡述
&lt;/h4>&lt;p>Group Commit 是 MySQL 5.6 版本引入用來優化 BinLog、RedoLog 在 2PC 時寫入的瓶頸，簡單來說原本每個 Transaction 都需要獨自 &lt;code>fsync&lt;/code> 操作來寫入 Disk 持久化，經過 Group Commit 的優化後會將多個 Transaction 組成一個對列一起進行 &lt;code>fsync&lt;/code> 操作，大幅減少 &lt;code>fsync&lt;/code> 操作解決在雙 1 時造成的性能急速下降的問題。&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/MySQL-5.6-GroupCommit.png"
width="2000"
height="734"
srcset="https://FuweaY.github.io/p/mysql-mts/MySQL-5.6-GroupCommit_hu_68a640d24557e5a3.png 480w, https://FuweaY.github.io/p/mysql-mts/MySQL-5.6-GroupCommit_hu_a620e3a9d84860da.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="653px"
>&lt;/p>
&lt;p>關於 Group Commit 的具體描述，可參考 &lt;a class="link" href="https://FuweaY.github.io/p/mysql-group-commit/" >MySQL Group Commit 演進&lt;/a>。&lt;/p>
&lt;h4 id="slave_parallel_type">slave_parallel_type
&lt;/h4>&lt;p>在 MySQL 5.7 引入了 &lt;code>slave_parallel_type&lt;/code> 這個新參數，可使用的值有以下 2 個：&lt;/p>
&lt;ul>
&lt;li>DATABASE：也就是 5.6 版本，不同 DATABASE 的才能並行回放。&lt;/li>
&lt;li>LOGICAL_CLOCK：5.7 版本基於 Group Commit 的並行回放。&lt;/li>
&lt;/ul>
&lt;h4 id="logical_clock---commit-parent-based-模式">LOGICAL_CLOCK - Commit Parent Based 模式
&lt;/h4>&lt;p>在 Source 中能夠在同一個對列一起進行 Group commit，表示這個對列中的所有 Transaction 都沒有鎖衝突，因此也可在 Replica 內並行回放。&lt;/p>
&lt;p>為了讓 Replica 能基於 Group Commit 實現 MTS，在 Binlog 中為每個 Transaction 添加了 LOGICAL CLOCK 也就是以下 2 個值：&lt;/p>
&lt;ul>
&lt;li>sequence_number：每個 Transaction 的唯一序列號，具體在 Transaction 進入 flush 階段的對列之前分配。&lt;/li>
&lt;li>last_commited：紀錄上次 Group commit 時最大的 sequence_number，也就是說 last_committed 相同表示同屬一個 Group。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/binlog-sequence-last-example.png"
width="2000"
height="503"
srcset="https://FuweaY.github.io/p/mysql-mts/binlog-sequence-last-example_hu_6de35104bba7a66b.png 480w, https://FuweaY.github.io/p/mysql-mts/binlog-sequence-last-example_hu_de30a8103e12b021.png 1024w"
loading="lazy"
alt="透過 mysqlbinlog 可以看到 binlog 中每個 Transaction 都有這 2 個變量"
class="gallery-image"
data-flex-grow="397"
data-flex-basis="954px"
>&lt;/p>
&lt;p>透過 mysqlbinlog 可以看到 binlog 中每個 Transaction 都有這 2 個變量&lt;/p>
&lt;p>備註：sequence_number、last_commited 只在同一個 BinLog 文件不重複，每當換到新的 BinLog 文件時會重新從 0 開始計數。&lt;/p>
&lt;hr>
&lt;p>不過 Commit Parent Based 有一個缺陷，讓我們看一下例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Trx1 ------------P----------C--------------------------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Trx2 ----------------P------+---C----------------------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Trx3 -------------------P---+---+-----C----------------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | | |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Trx4 -----------------------+-P-+-----+----C-----------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | | | |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Trx5 -----------------------+---+-P---+----+---C-------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> | | | | |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Trx6 -----------------------+---+---P-+----+---+---C----------&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每一個水平線代表一個 Transaction 由左到右的時間點，其中 P 表示 prepare 階段取得上一個 Group 更新 last_committed 的時間點，C 表示 commit 前更新 last_committed 的時間點。&lt;/p>
&lt;p>其中可以觀察到：&lt;/p>
&lt;ul>
&lt;li>Trx4 的 P 時間點取得的是 Trx1 commit 產生的 last_committed&lt;/li>
&lt;li>Trx5 和 Trx6 的 P 時間點取得的是 Trx2 commit 產生的 last_committed&lt;/li>
&lt;/ul>
&lt;p>依照 Commit Parent 模式下 Trx5、Trx6 可以一起在 Replica 回放，但是 Trx4 不可以和 Trx5、Trx6 一起在 Replica 回放。&lt;/p>
&lt;p>然而，實際上依照時間線我們可以看到 Trx4 在 prepare 到 commit 的過程中，Trx5、Trx6 有在這個過程中 prepare，也就是說實際上他們並沒有鎖衝突 (如果衝突 Trx5、Trx6 會卡在 lock wait)，所以理論上他們在 Replica 是可以並行回放到。&lt;/p>
&lt;h4 id="logical_clock----lock-based-模式">LOGICAL_CLOCK - Lock Based 模式
&lt;/h4>&lt;p>為了進一步優化 Commit Parent Based 的缺陷，MySQL 5.7 馬上實現了 &lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=7165" target="_blank" rel="noopener"
>MySQL :: WL#7165: MTS: Optimizing MTS scheduling by increasing the parallelization window on master&lt;/a> 的優化，也就是基於 Lock Based 模式的 LOGICAL_CLOCK，只要 Transaction 在各自持有的鎖沒有衝突時就可以並行執行。&lt;/p>
&lt;p>在此模式下 binlog 中的 sequence_number、last_commited 涵義如下：&lt;/p>
&lt;ul>
&lt;li>sequence_number：每個 Transaction 的唯一序列號，具體在 Transaction 進入 flush 階段的對列之前分配，&lt;/li>
&lt;li>last_commited：當 Transaction 開始加鎖時，將全局變量 max_committed_transaction 當下的值作為 last_commited。
&lt;ul>
&lt;li>全局變量 max_committed_transaction：已經結束 Lock interval 的最大 sequence_number，每個 Transaction 在 InnoDB commit 階段時，如果自己的 sequence_number &amp;gt; max_committed_transaction 時會將其更新為自己的 sequence_number 。&lt;/li>
&lt;li>因為無法預先知道哪一個鎖是最後一個，因此 Transaction 內每一個 DML 都會不斷更新該 Transaction 的 last_commited。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在 Source 寫入 sequence_number、last_commited 之後，接下來就是看 Replica 如何依據這 2 個直來實現 Lock Based 的 MTS。&lt;/p>
&lt;p>首先複習一下，只有當 Transaction 和 Transaction 在 Lock ~ Commit (也就是釋放鎖) 之間有交集才能在 Replica 並行回放：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">- Can execute in parallel:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx1 -----L---------C------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx2 ----------L---------C-------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">- Can not execute in parallel:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx1 -----L----C-----------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx2 ---------------L----C-------&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>讓我們首先為上圖中的 L~C 的期間定義一個新的名詞 &lt;code>Lock interval&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>Lock interval 的起始點(上圖L)：在 Binlog Prepare 階段取得最後一把鎖的時間點。&lt;/li>
&lt;li>Lock interval 的結束點(上圖C)：在 InnoDB Commit 階段釋放第一把鎖的時間點。&lt;/li>
&lt;/ul>
&lt;p>也就是說對於 Replica 在讀取 BinLog 時：&lt;/p>
&lt;ul>
&lt;li>last_commited 作為 Lock interval 的起始點：因為 Transaction 開始加鎖的邏輯時間是目前最後一個已結束 lock interval 的最後一個 sequence_number，就是全局變量 max_committed_transaction。&lt;/li>
&lt;li>sequence_number 作為 Lock interval 的結束點：因為當該 Transaction 結束 lock interval 時會將自己的 sequence_number 更新到 max_committed_transaction，也就是說對於下個 Transaction 而言的 last_commited。&lt;/li>
&lt;/ul>
&lt;p>在 Replica 回放時只有 Transaction 之間如果 last_commited~sequence_number 之間有重疊就可以並行回放。&lt;/p>
&lt;p>實現方式如下：&lt;/p>
&lt;ul>
&lt;li>定義一個變量 &lt;code>last_lwm_timestamp&lt;/code>：為一個已經完成回放 Transaction 的 sequence_number ，該 Transaction 其 sequence_number 之前的所有 Transaction 都已經 commit。&lt;/li>
&lt;li>當 coordinator 線程讀取一個 Transaction 的 last_committed：
&lt;ul>
&lt;li>
&lt;p>當 &lt;code>last_committed&lt;/code> &amp;lt; &lt;code>last_lwm_timestamp&lt;/code> 表示 Lock interval 有交集，因此可以丟給 work 線程並行回放。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> Trx1 -----L---------C------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx2 ----------L---------C-------&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>當 &lt;code>last_committed&lt;/code> = &lt;code>last_lwm_timestamp&lt;/code> 雖然 Lock interval 沒有交集，但是該情況表示前一個 Transaction 完成，所以當前 Transaction 才會拿到前一個的 sequence_number 作為自己的 last_commited，而 &lt;code>last_lwm_timestamp&lt;/code> 是已經 commit 的 Transaction，因此可以丟給 work 線程回放了。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> Trx1 -----L----C-----------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx2 ----------L---------C-------&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>當 &lt;code>last_committed&lt;/code> &amp;gt; &lt;code>last_lwm_timestamp&lt;/code> 表示 Lock interval 沒有交集，因此不能丟給 work 線程並行回放。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> Trx1 -----L----C-----------------&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Trx2 ---------------L----C-------&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="commit-parent-based-vs-lock-based--舉例">Commit Parent Based VS Lock Based 舉例
&lt;/h4>&lt;p>假設有以下 binlog：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/Commit-vs-Lock-Binlog-example.png"
width="755"
height="282"
srcset="https://FuweaY.github.io/p/mysql-mts/Commit-vs-Lock-Binlog-example_hu_f5f40e55cf9bafe5.png 480w, https://FuweaY.github.io/p/mysql-mts/Commit-vs-Lock-Binlog-example_hu_3613004070a757c1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="267"
data-flex-basis="642px"
>&lt;/p>
&lt;p>在 Commit Parent Based 下：&lt;/p>
&lt;ul>
&lt;li>sequence_number 1~7 的 Transaction 其 last_committed 都是 0，所以可在 replica 並行回放。&lt;/li>
&lt;li>sequence_number 8 的 Transaction 其 last_committed 是 1，所以不能和 sequence_number 1~7一起在 replica 並行回放。
*備註：在 Commit Parent Based 下，正確的 last_committed 應該要是 7，此處僅方便舉例使用 Lock Based 舉例。&lt;/li>
&lt;li>sequence_number 9&lt;del>14 的 Transaction 其 last_committed 都是 7，不能和 sequence_number 1&lt;/del>8 一起在 replica 並行回放。&lt;/li>
&lt;/ul>
&lt;p>在 Lock Based 下：&lt;/p>
&lt;ul>
&lt;li>sequence_number 1&lt;del>7 的 Transaction 其 last_committed 都是 0 表示為同一個 Group，所以 1&lt;/del>7 可在 replica 並行回放。&lt;/li>
&lt;li>sequence_number 8 的 last_committed = 1，表示 8 和 1&lt;del>7 的鎖不衝突，因此 1&lt;/del>8 可在 replica 並行回放。&lt;/li>
&lt;li>sequence_number 9&lt;del>14 的 Transaction 其 last_committed 都是 7 表示為同一個 Group，同時 8&lt;/del>14 的鎖不衝突，因次 8~14 可在 replica 並行回放&lt;/li>
&lt;/ul>
&lt;h4 id="缺陷">缺陷
&lt;/h4>&lt;p>基於 Group Commit 的 MTS 不論是 Commit Parent Based 還是 Lock Based 都一樣，都是只有在 Source 上每個 Group 的 Transaction 足夠多，也就是併發度夠高的情況下才能在 Replica 上有較好的並行回放效率。&lt;/p>
&lt;p>雖然在 5.7 新增 &lt;code>binlog_group_commit_sync_delay&lt;/code>、&lt;code>binlog_group_commit_sync_no_delay_count&lt;/code>這 2 個設定，可以讓一個 Group 有更多的 Transaction，然而效果仍然十分有限。&lt;/p>
&lt;h3 id="基於-writeset-的-mts-572280">基於 WriteSet 的 MTS (5.7.22、8.0)
&lt;/h3>&lt;p>MySQL 5.7 雖然透過 Group Commit 優化了 MTS，但這主要是優化在 Master 上有高並行度的情況下，如果 Master 並行度不高則同一個 Group 的 Event 相對少，因此 Slave 回放速度無法有效加快。&lt;/p>
&lt;p>在 8.0 為了解決上述問題，即使在 Source 上是串行 commit 的 Transaction，只要互相不衝突那麼在 Replica 上就能並行回放。&lt;/p>
&lt;p>在 8.0 新增了 &lt;code>binlog_transaction_dependency_tracking&lt;/code> 這個參數來控制 binlog 寫入相關資訊，讓 Replica 據此進行並行回放，有以下三個值：&lt;/p>
&lt;ul>
&lt;li>COMMIT_ORDER：使用 5.7 Group commit 的方式判斷。&lt;/li>
&lt;li>WRITESET：使用 WriteSet 的方式判斷 Transaction 是否有衝突。&lt;/li>
&lt;li>WRITESET_SESSION：WRITESET 的基礎上保證同一個 session 內的 Transaction 不可並行。&lt;/li>
&lt;/ul>
&lt;h4 id="writeset-簡述">WriteSet 簡述
&lt;/h4>&lt;p>&lt;code>WriteSet&lt;/code> 在 MySQL Group Replication(MGR) 中就已經實現了：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/MySQL-Group-Replication-Protocol.png"
width="725"
height="328"
srcset="https://FuweaY.github.io/p/mysql-mts/MySQL-Group-Replication-Protocol_hu_e322ba252aa71e47.png 480w, https://FuweaY.github.io/p/mysql-mts/MySQL-Group-Replication-Protocol_hu_21b180ab73ce6bc5.png 1024w"
loading="lazy"
alt="MySQL Group Replication Protocol"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="530px"
>&lt;/p>
&lt;p>&lt;strong>MySQL Group Replication Protocol&lt;/strong>&lt;/p>
&lt;p>使用的地方是 certify 階段用來判斷 Transaction 是否允許 commit，這個時候就會透過 &lt;code>WriteSet&lt;/code> 來判斷是否和其他 member 上的 Transaction 有衝突。&lt;/p>
&lt;blockquote>
&lt;p>💡 因為 MGR 可以在多個 member 上寫入，因此不像單機模式可以透過 Lock 衝突來避免 Transaction 之間的衝突，同時為了提高效能 MGR 採用樂觀的方式不透過其他方式額外加鎖，只有準備 commit 的時候透過 &lt;code>WriteSet&lt;/code> 判斷 member 之間的 Transaction 是否衝突。&lt;/p>&lt;/blockquote>
&lt;h4 id="writeset-應用到-mts-簡述">WriteSet 應用到 MTS 簡述
&lt;/h4>&lt;p>假設在 Source 上 Transaction commit 時間軸如下，同一個時間只有 1~2 個 Transaction：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/WriteSet-Master-Exe.png"
width="648"
height="380"
srcset="https://FuweaY.github.io/p/mysql-mts/WriteSet-Master-Exe_hu_4b68f14e9e9e9c30.png 480w, https://FuweaY.github.io/p/mysql-mts/WriteSet-Master-Exe_hu_d08660c747a2776c.png 1024w"
loading="lazy"
alt="Source 執行狀況"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>上途中方塊對應 Transaction 修改的資料範圍，如果沒有重疊表示 Transaction 之間修改的數據不衝突，那麼透過 WriteSet 判斷 Transaction 之間是否衝突後，就可以在 Replica上如下並行：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/WriteSet-MTS.png"
width="632"
height="370"
srcset="https://FuweaY.github.io/p/mysql-mts/WriteSet-MTS_hu_86231a346efed00b.png 480w, https://FuweaY.github.io/p/mysql-mts/WriteSet-MTS_hu_be99f3b638c3b1d0.png 1024w"
loading="lazy"
alt="基於 WriteSet 的 MTS 回放狀況"
class="gallery-image"
data-flex-grow="170"
data-flex-basis="409px"
>&lt;/p>
&lt;p>不過上圖有個小問題是可能發生 T3 比 T2 早執行的狀況，導致 Source 和 Replica 中同一個 session 產生有不同的執行紀錄，如果評估後覺得不可接受有以下 2 個方式可以解決：&lt;/p>
&lt;ul>
&lt;li>slave_preserve_commit_order = ON&lt;/li>
&lt;li>binlog_transaction_dependency_tracking = WRITESET_SESSION&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order-on.png"
width="643"
height="385"
srcset="https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order-on_hu_e87cd167b19860.png 480w, https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order-on_hu_24a9cbd16fb7acf6.png 1024w"
loading="lazy"
alt="基於 WRITESET_SESSION 或 slave_preserve_commit_order = ON 設定後 MTS 回放狀況"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="400px"
>&lt;/p>
&lt;p>如上圖調整後可以發現同一個 session 的都不能並行回放。&lt;/p>
&lt;h4 id="實現方式">實現方式
&lt;/h4>&lt;h3 id="writeset-是什麼">WriteSet 是什麼？
&lt;/h3>&lt;p>WriteSet 是一個 hash 數組，大小由 &lt;code>binlog_transaction_dependency_history_size&lt;/code> 來決定。&lt;/p>
&lt;p>在 InooDB 修改數據後，會將修改的 row 數據以下內容進行 hash 後寫入 &lt;code>WriteSet&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/WriteSet-internal-Structure.png"
width="1080"
height="61"
srcset="https://FuweaY.github.io/p/mysql-mts/WriteSet-internal-Structure_hu_4e3a3c9ac483c1d2.png 480w, https://FuweaY.github.io/p/mysql-mts/WriteSet-internal-Structure_hu_d2aceffb4048a3f4.png 1024w"
loading="lazy"
alt="WriteSet 結構"
class="gallery-image"
data-flex-grow="1770"
data-flex-basis="4249px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>WriteSet 產出細節&lt;/p>
&lt;blockquote>
&lt;p>💡 產生的 Hash 值的方式可以參考 sql/rpl_write_set_handler.cc 中的 add_pke function
&lt;a class="link" href="https://github.com/mysql/mysql-server/blob/8.0/sql/rpl_write_set_handler.cc" target="_blank" rel="noopener"
>mysql-server/rpl_write_set_handler.cc at 8.0 · mysql/mysql-server · GitHub&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>範例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">use&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Database&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">changed&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">show&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">***************************&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">***************************&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">Table&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Create&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Table&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">CREATE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TABLE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">pk_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">uk_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">idx_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NOT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">PRIMARY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">pk_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">UNIQUE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">uk_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">uk_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">KEY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">idx_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="n">idx_column&lt;/span>&lt;span class="o">`&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ENGINE&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">InnoDB&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">DEFAULT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CHARSET&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">utf8mb4&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INSERT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">INTO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">db_name&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">table_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">VALUES&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">7&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">8&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 透過編譯 mysqld debug 執行查看&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">~ -&amp;gt; tail -f /tmp/mysqld.trace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;lt;generate_hash_pke &lt;span class="m">441&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;gt;generate_hash_pke
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;gt;Rpl_transaction_write_set_ctx::add_write_set
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;lt;Rpl_transaction_write_set_ctx::add_write_set &lt;span class="m">51&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> info: pke: PRIMARY½db_name½7table_name½106½1&lt;span class="p">;&lt;/span> hash: &lt;span class="m">10113078337023140702&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;lt;generate_hash_pke &lt;span class="m">441&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;gt;generate_hash_pke
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;gt;Rpl_transaction_write_set_ctx::add_write_set
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &amp;lt;Rpl_transaction_write_set_ctx::add_write_set &lt;span class="m">51&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">T@6: &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> info: pke: uk_column½db_name½7table_name½107½1&lt;span class="p">;&lt;/span> hash: &lt;span class="m">406567197175550244&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>偽代碼如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="err">如果表中存在索引：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">将数据库名，表名信息写入临时变量&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">循环扫描表中每个索引：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">如果不是唯一索引：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">退出本次循环继续循环。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">循环两种生成数据的方式&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">二进制格式和字符串格式&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="err">：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">将索引名字写入到&lt;/span>&lt;span class="n">pke中&lt;/span>&lt;span class="err">。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">将临时变量信息写入到&lt;/span>&lt;span class="n">pke中&lt;/span>&lt;span class="err">。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">循环扫描索引中的每一个字段：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">将每一个字段的信息写入到&lt;/span>&lt;span class="n">pke中&lt;/span>&lt;span class="err">。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">如果字段扫描完成：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">将&lt;/span>&lt;span class="n">pke生成hash值并且写入到写集合中&lt;/span>&lt;span class="err">。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">如果没有找到主键或者唯一键记录一个标记，后面通过这个标记来&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">判定是否使用&lt;/span>&lt;span class="n">Writeset的并行复制方式&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="基於-writeset-的-mts-怎麼實現">基於 WriteSet 的 MTS 怎麼實現？
&lt;/h3>&lt;p>該模式下 Replica 同樣是基於 Source 產生的 binlog 中的 &lt;code>last_commited&lt;/code> 和 &lt;code>sequenct_number&lt;/code> 來決定是否可以並行回放，也就是說如果要進一步增加並行回放的效率，就需要盡可能為每個 Transaction 找出更小的 &lt;code>last_commited&lt;/code>。&lt;/p>
&lt;p>基於 WriteSet 的 MTS 能找出更小的 &lt;code>last_commited&lt;/code> 的方式就是維護一個先前 Transaction 所組成的 WriteSet 的歷史紀錄，之後新進來的 Transaction 計算 WriteSet 後和這個歷史紀錄進行衝突比對，以此來嘗試找出更小的 &lt;code>last_commited&lt;/code>。&lt;/p>
&lt;h4 id="binlog_transaction_dependency_tracking-不同對-last_commit-的處理">binlog_transaction_dependency_tracking 不同對 last_commit 的處理
&lt;/h4>&lt;p>基於 WriteSet 的 MTS 實際上是基於 ORDER_COMMIT (Group Commit) 進一步處理而已。&lt;/p>
&lt;p>根據 binlog_transaction_dependency_tracking 的設定不同，在 Source code 有如下內容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">case&lt;/span> &lt;span class="nl">DEPENDENCY_TRACKING_COMMIT_ORDER&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_commit_order&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">case&lt;/span> &lt;span class="nl">DEPENDENCY_TRACKING_WRITESET&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_commit_order&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">case&lt;/span> &lt;span class="nl">DEPENDENCY_TRACKING_WRITESET_SESSION&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_commit_order&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset_session&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">get_dependency&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">break&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到從 COMMIT_ORDER 到 WRITESET 再到 WRITESET_SESSION 其實都是以上一個設定的為基礎進一步透過一個新的 function 進行修改而已，這些 function 修改的是 &lt;code>last_commited&lt;/code> 值。&lt;/p>
&lt;h4 id="writeset-歷史紀錄詳解">WriteSet 歷史紀錄詳解
&lt;/h4>&lt;p>WriteSet 的歷史紀錄包含了 2 個元素：&lt;/p>
&lt;ul>
&lt;li>WriteSet 的 Hash 值&lt;/li>
&lt;li>最後一次修改該行的 Transaction 其 &lt;code>sequence_number&lt;/code>&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Track the last transaction sequence number that changed each row
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> in the database, using row hashes from the writeset as the index.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">typedef&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">uint64&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">int64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">Writeset_history&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//map实现
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">Writeset_history&lt;/span> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>另外 &lt;code>binlog_transaction_dependency_history_size&lt;/code> 決定了可以儲存幾組紀錄，內部會依照 WriteSet Hash 值進行排序。&lt;/p>
&lt;p>如果 WriteSet 的歷史紀錄達到 &lt;code>binlog_transaction_dependency_history_size&lt;/code> 設定的值就會將歷史紀錄清空，並且本次的 Transaction 會成為清空後歷史紀錄的第一筆紀錄。&lt;/p>
&lt;p>另外除了歷史紀錄還有有一個 &lt;code>m_writeset_history_start&lt;/code> 的值，用來儲存這個歷史紀錄中的最小 &lt;code>sequence_number&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exceeds_capacity&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">can_use_writesets&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//Writeset的历史MAP已满
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset_history_start&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果超过最大设置，清空writeset history。从当前seq number 重新记录， 也就是最小的那个事务seq number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clear&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//清空历史MAP
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="writeset-mts-對-last_commit-的處理流程">WriteSet MTS 對 last_commit 的處理流程
&lt;/h4>&lt;p>這裡透過一個例子解釋，假設如下：&lt;/p>
&lt;ul>
&lt;li>當前的 Transaction 基於 ORDER_COMMIT (Group Commit) 的方式產生了結果：
&lt;ul>
&lt;li>last_commit = 125&lt;/li>
&lt;li>sequence_number = 130&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>該 Transaction 修改的表只有 PK 沒有 UK。&lt;/li>
&lt;li>該 Transaction 修改了 4 行資料，分別為 ROW1、ROW7、ROW6、ROW10。&lt;/li>
&lt;/ul>
&lt;p>下圖展示了該 Transaction 和 WriteSet 歷史紀錄：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/WriteSet-search-lastCommit.png"
width="1120"
height="1069"
srcset="https://FuweaY.github.io/p/mysql-mts/WriteSet-search-lastCommit_hu_615814ac450fa60f.png 480w, https://FuweaY.github.io/p/mysql-mts/WriteSet-search-lastCommit_hu_d78a2671fa2b38d4.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="104"
data-flex-basis="251px"
>&lt;/p>
&lt;p>接下來就會透過 WriteSet 方式找到更小的 last_commit：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>將 last_commit 由 125 調整為 100 (歷史紀錄中最小的 sequence_number &lt;code>m_writeset_history_start&lt;/code>)。&lt;/p>
&lt;p>備註：因為該 Transaction 比歷史紀錄中的 Transaction 晚執行，因此 last_commit 一定都比他們的 sequence_number 大。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>將 ROW1 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：&lt;/p>
&lt;ul>
&lt;li>將歷史紀錄中該行的 sequence_number 由 120 (歷史紀錄值) 調整為 130(該 Transaction)。&lt;/li>
&lt;li>將該 Transaction 的 last_commit 由 100 調整為 120。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>將 ROW7 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：&lt;/p>
&lt;ul>
&lt;li>將歷史紀錄中該行的 sequence_number 由 114 (歷史紀錄值) 調整為 130(該 Transaction)。&lt;/li>
&lt;li>當前 Transaction 當前 last_commit 為 120 比歷史紀錄中的 114 大，因為在 120 就衝突了，所以不能改成更小的 114，因此 last_commit 不變依舊是 120。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>將 ROW6 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：&lt;/p>
&lt;ul>
&lt;li>將歷史紀錄中該行的 sequence_number 由 105 (歷史紀錄值) 調整為 130(該 Transaction)。&lt;/li>
&lt;li>當前 Transaction 當前 last_commit 為 120 比歷史紀錄中的 105 大，因為在 120 就衝突了，所以不能改成更小的 105，因此 last_commit 不變依舊是 120。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>將 ROW10 的 Hash 值在 WriteSet 歷史紀錄中確認，發現並沒有修改相同紀錄的 Transaction：&lt;/p>
&lt;ul>
&lt;li>因為沒有找到相同的 WriteSet，因此需要把該 Transaction ROW10 的 Hast 值和 sequence_number 寫入 WriteSet 歷史紀錄。
&lt;ul>
&lt;li>如果歷史紀錄大小超過 &lt;code>binlog_transaction_dependency_history_size&lt;/code>，則清空當前歷史紀錄，隨後將 Transaction ROW10 的 Hast 值和 sequence_number(130) 寫入 WriteSet 新的歷史紀錄，並將 &lt;code>m_writeset_history_start&lt;/code> 改為 130。&lt;/li>
&lt;li>如果歷史紀錄大小沒有超過 &lt;code>binlog_transaction_dependency_history_size&lt;/code>，將 Transaction ROW10 的 Hast 值和 sequence_number(130) 寫入 WriteSet 當前歷史紀錄。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>整個過程結束，該 Transaction 的 last_commit 由原本的 125 降低為 120，最後結果如下圖：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/WriteSet-Change-lastCommit.png"
width="1117"
height="1104"
srcset="https://FuweaY.github.io/p/mysql-mts/WriteSet-Change-lastCommit_hu_5ae3d1b1f4d24fcd.png 480w, https://FuweaY.github.io/p/mysql-mts/WriteSet-Change-lastCommit_hu_35d7a891f6ed0d5f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="101"
data-flex-basis="242px"
>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>該過程在 Function &lt;code>Writeset_trx_dependency_tracker::get_dependency&lt;/code> 中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;span class="lnt">54
&lt;/span>&lt;span class="lnt">55
&lt;/span>&lt;span class="lnt">56
&lt;/span>&lt;span class="lnt">57
&lt;/span>&lt;span class="lnt">58
&lt;/span>&lt;span class="lnt">59
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">can_use_writesets&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">//如果能够使用writeset 方式
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Check if adding this transaction exceeds the capacity of the writeset
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> history. If that happens, m_writeset_history will be cleared only after 而 add_pke
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> using its information for current transaction.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">exceeds_capacity&lt;/span>&lt;span class="o">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">writeset&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">m_opt_max_history_size&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果大于参数binlog_transaction_dependency_history_size设置清理标记
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> Compute the greatest sequence_number among all conflicts and add the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> transaction&amp;#39;s row hashes to the history.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">int64&lt;/span> &lt;span class="n">last_parent&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">m_writeset_history_start&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//临时变量，首先设置为最小的一个seq number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">set&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">uint64&lt;/span>&lt;span class="o">&amp;gt;::&lt;/span>&lt;span class="n">iterator&lt;/span> &lt;span class="n">it&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">writeset&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">begin&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="n">it&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">writeset&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="o">++&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//循环每一个Writeset中的每一个元素
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Writeset_history&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">iterator&lt;/span> &lt;span class="n">hst&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//是否在writeset history中 已经存在了。 map中的元素是 key是writeset 值是sequence number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hst&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">end&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="c1">//如果存在
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hst&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">last_parent&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">hst&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">second&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">last_parent&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">hst&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果已经大于了不需要设置
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">hst&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">second&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//更改这行记录的sequence_number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">exceeds_capacity&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">pair&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">uint64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">int64&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//没有冲突则插入。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">......&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="o">!&lt;/span>&lt;span class="n">write_set_ctx&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">get_has_missing_keys&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果没有主键和唯一键那么不更改last commit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="cm">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> The WRITESET commit_parent then becomes the minimum of largest parent
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> found using the hashes of the row touched by the transaction and the
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> commit parent calculated with COMMIT_ORDER.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cm"> */&lt;/span>&lt;span class="err">；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">commit_parent&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">min&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">last_parent&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//这里对last commit做更改了。降低他的last commit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">exceeds_capacity&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">can_use_writesets&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">m_writeset_history_start&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果超过最大设置 清空writeset history。从当前sequence 重新记录 也就是最小的那个事务seqnuce number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">m_writeset_history&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clear&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="c1">//清空真个MAP
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="writeset_session-怎麼做">WRITESET_SESSION 怎麼做?
&lt;/h4>&lt;p>前面有提到過 WRITESET_SESSION 是基於 WRITESET 的基礎上繼續處理的，WRITESET_SESSION 要做到的是同一個 session 的 Transaction 不能在 Replica 並行回放，要實現非常簡單：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">int64&lt;/span> &lt;span class="n">session_parent&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">thd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rpl_thd_ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dependency_tracker_ctx&lt;/span>&lt;span class="p">().&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">get_last_session_sequence_number&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//取本session的上一次事务的seq number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">session_parent&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">session_parent&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="n">sequence_number&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//如果本session已经做过事务并且本次当前的seq number大于上一次的seq number
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">commit_parent&lt;/span>&lt;span class="o">=&lt;/span> &lt;span class="n">std&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">commit_parent&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">session_parent&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//说明这个session做过多次事务不允许并发，修改为order_commit生成的last commit
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">thd&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">rpl_thd_ctx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dependency_tracker_ctx&lt;/span>&lt;span class="p">().&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">set_last_session_sequence_number&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">sequence_number&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//设置session_parent的值为本次seq number的值
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="關於-binlog_transaction_dependency_history_size-參數說明">關於 binlog_transaction_dependency_history_size 參數說明
&lt;/h4>&lt;p>該參數默認值為 25000，代表的是 WriteSet 裡元素的數量。&lt;/p>
&lt;p>從前面 WriteSet 實現細節說明中我們可以知道修改一行數據可能會產生多個 Hash，所以這個值不會等於修改的行數，可以理解為如下：&lt;/p>
&lt;ul>
&lt;li>5.7 版本：binlog_transaction_dependency_history_size = 修改的行數 * ( 1 + UK 數量 ) * 2&lt;/li>
&lt;li>8.0 版本：binlog_transaction_dependency_history_size = 修改的行數 * ( 1 + UK 數量 )&lt;/li>
&lt;/ul>
&lt;p>備註：不同原因在於 5.7 會生成包含 collation 和不包含 collation，在 8.0 中則沒有。&lt;/p>
&lt;p>如果將這個參數加大，那麼 Source 上的 WriteSet 就能放越多的元素，也就是說 Transaction 可以生成更小的 last_commited，這在 Replica 上就能提高並行回放的效率，當然缺點就是在 Source 會消耗更多的資源。&lt;/p>
&lt;h4 id="writeset-不適用情境">WriteSet 不適用情境
&lt;/h4>&lt;p>以下情境不適用 WriteSet，MySQL 會自動退回使用 commit_order (基於 group commit) 模式&lt;/p>
&lt;ol>
&lt;li>沒有 PK 也沒有 UK&lt;/li>
&lt;li>DDL&lt;/li>
&lt;li>session 的 hash 算法換 history 不同&lt;/li>
&lt;li>Transaction 更新了有 Forign key 關聯的欄位&lt;/li>
&lt;/ol>
&lt;h2 id="slave_">&lt;strong>slave_preserve_commit_order 介紹&lt;/strong>
&lt;/h2>&lt;p>當開啟 MTS 且 slave_parallel_type = LOGICAL_CLOCK (不論具體是基於 commit_order 還是 writeset) 的時候，有可能會發生 Source 和 Replica 執行順序不同的情況，雖然這並不會導致資料不一致的狀況，但是可能會發生在 Source 上先看到 T1 才看到 T2 卻在 Replica 上卻是先看到 T2 才看到 T1 執行，也就是說在 Source 和 Replica 各自的 binlog 歷史紀錄順序也會不一致，沒有保證 &lt;code>Causal Consistency&lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>💡 &lt;code>Causal Consistency&lt;/code> (因果一致性) 意思是如果兩個事件有因果關係，那麼在所有節點都必須能觀測到這種因果關係。&lt;/p>&lt;/blockquote>
&lt;p>如果評估業務需要保證&lt;code>Causal Consistency&lt;/code>，除了不使用 MTS 使用單線程 replication 也可以透過設置 &lt;code>slave_preserve_commit_order=ON&lt;/code> 來避免，這會讓 Replica 上回放的 Transaction 在進入 flush 階段之前會先等待 sequence_number 之前的 Transaction 先進入 flush 階段。&lt;/p>
&lt;h3 id="gap">GAP
&lt;/h3>&lt;p>如果 &lt;code>slave_preserve_commit_order = OFF&lt;/code> 除了上面提到 &lt;code>Causal Consistency&lt;/code> 還有一個問題在官方文檔中稱為 GAP。&lt;/p>
&lt;p>開啟 MTS 時透過 show slave status 查看 &lt;code>Exec_Source_Log_Pos&lt;/code> 指的是 &lt;code>low-watermark&lt;/code> 也就是保證這個 postition 之前的 Transaction 都已經 commit，但是該 postition 之後的 Transaction 有可能 commit 也可能沒有 commit，&lt;/p>
&lt;h2 id="相關參數">相關參數
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_parallel_workers" target="_blank" rel="noopener"
>slave_parallel_workers&lt;/a> (5.6 ~ 8.0.25)、&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_parallel_workers" target="_blank" rel="noopener"
>replica_parallel_workers&lt;/a> (8.0.26 ~)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/slave-parallel-workers.png"
width="575"
height="343"
srcset="https://FuweaY.github.io/p/mysql-mts/slave-parallel-workers_hu_4d041eb8e44d22f6.png 480w, https://FuweaY.github.io/p/mysql-mts/slave-parallel-workers_hu_ec466e839f6fe4b6.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="402px"
>&lt;/p>
&lt;p>設定要在 replica 並行的 thread 數量。&lt;/p>
&lt;p>如果 slave 有多個 channel，則每個 channel 都會有此數量的 thread。&lt;/p>
&lt;p>設置此參數後必須重新 START REPLICA 才會生效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_parallel_type" target="_blank" rel="noopener"
>slave_parallel_type&lt;/a> (5.7 ~ 8.0.25)、&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_parallel_type" target="_blank" rel="noopener"
>replica_parallel_type&lt;/a> (8.0.26 ~ 8.0.29)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/replica-parallel-type.png"
width="574"
height="366"
srcset="https://FuweaY.github.io/p/mysql-mts/replica-parallel-type_hu_3bead051496654f6.png 480w, https://FuweaY.github.io/p/mysql-mts/replica-parallel-type_hu_1946b811ede79cec.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="156"
data-flex-basis="376px"
>&lt;/p>
&lt;p>設定在 replica 上允許哪些 Transaction 並行回放&lt;/p>
&lt;ul>
&lt;li>DATABASE：Transaction 必須作用於不同 Database 才能並行。&lt;/li>
&lt;li>LOGICAL_CLOCK：基於 Source 寫入 binlog 的 timestamp 來決定 Transaction 的並行，也就是基於 Group Commit。&lt;/li>
&lt;/ul>
&lt;p>建議將 binlog_transaction_dependency_tracking 設置為 WRITESET 或 WRITESET_SESSION ，這樣在合適的情況下會走 WriteSet 來提高並行度。&lt;/p>
&lt;p>預計 8.0.29 之後棄用此參數，總是以 LOGICAL_CLOCK 的方式運行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_group_commit_sync_delay" target="_blank" rel="noopener"
>binlog_group_commit_sync_delay&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-delay.png"
width="575"
height="313"
srcset="https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-delay_hu_ef403cd4f4b0234.png 480w, https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-delay_hu_d0b4236f64d57c5d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="183"
data-flex-basis="440px"
>&lt;/p>
&lt;p>控制 binlog commit 之後等待 N 微秒後才 fsync 到 Disk，設置越大單個 Group 可以有更多時間等到更多的 Transaction 一起 fsync Disk，減少 fsync 的次數及減少每個 Transaction commit 的單位時間。&lt;/p>
&lt;p>此外適度的增加對於以下設置的 MTS 也能增加在 Slave 的並行度：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># Master
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_transaction_dependency_tracking = COMMIT_ORDER
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Slave
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_parallel_type = LOGICAL_CLOCK
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：會增加 server 上 transaction 的延遲，也就是 client 端收到 transaction commit 的時間會變晚，另外相應的會增加資源的競爭，因此需評估最好的設置。&lt;/p>
&lt;p>補充：在有 Group Commit 之後，sync_binlog 的單位指的是 Group 而不是 Transaction，例如：sync_binlog = 1000，表示的不是每 1000 個 Transaction 就 sync binlog，而是每 1000 個 Group 才 sync binlog。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_group_commit_sync_no_delay_count" target="_blank" rel="noopener"
>binlog_group_commit_sync_no_delay_count&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-no-delay-count.png"
width="575"
height="285"
srcset="https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-no-delay-count_hu_31a81363cebe4293.png 480w, https://FuweaY.github.io/p/mysql-mts/binlog-group-commit-sync-no-delay-count_hu_4454de47c2d58f5c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="201"
data-flex-basis="484px"
>&lt;/p>
&lt;p>在 Group commit 中等待的 N 個 Transaction 後就不等待 binlog_group_commit_sync_delay 設置的時間直接開始 sync binlog。&lt;/p>
&lt;p>當 binlog_group_commit_sync_delay = 0 ，此參數無效。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_preserve_commit_order" target="_blank" rel="noopener"
>slave_preserve_commit_order&lt;/a> (5.7 ~ 8.0.25)、&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_preserve_commit_order" target="_blank" rel="noopener"
>replica_preserve_commit_order&lt;/a> (8.0.26 ~)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order.png"
width="576"
height="281"
srcset="https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order_hu_850124080f73874.png 480w, https://FuweaY.github.io/p/mysql-mts/slave-preserve-commit-order_hu_59b2b2377aa92ade.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="204"
data-flex-basis="491px"
>&lt;/p>
&lt;p>只有當 slave_parallel_type = LOGICAL_CLOCK 且 log-slave-updates 開啟時才能設置。&lt;/p>
&lt;p>當設置為 0 或 OFF 時，在 Replica 上的讀取操作無法滿足 &lt;code>Causal Consistency&lt;/code> ，在 Source 和 Replica 上 Transaction 在 binlog 中可能有不同的寫入順序，另外在檢查 Replica 上最近執行的 Transaction 無法保證對應到 Source 上該 Transaction 位置之前的 Transaction 都已經執行完畢。&lt;/p>
&lt;p>設置為 1 或 ON 確保 Transaction 在執行時按照在 relay log 中的順序，這可以讓 Master 和 Replica 有相同的 Transaction history log，也就是符合 &lt;code>Causal Consistency&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_dependency_tracking" target="_blank" rel="noopener"
>binlog_transaction_dependency_tracking&lt;/a> (5.7.22 ~)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-tracking.png"
width="575"
height="298"
srcset="https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-tracking_hu_706dc27ebec643cc.png 480w, https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-tracking_hu_3fd8ed4baf5eeb2c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="192"
data-flex-basis="463px"
>&lt;/p>
&lt;p>指定 Source 依據什麼方式來生成 Transaction 之間的依賴關係寫入 binlog，協助 Replica 確定那些 Transaction 能夠並行執行。&lt;/p>
&lt;p>必須設置 replica_parallel_type 為 LOGICAL_CLOCK。&lt;/p>
&lt;p>有以下三種值：&lt;/p>
&lt;ul>
&lt;li>COMMIT_ORDER：使用 5.7 Group commit 的方式判斷。&lt;/li>
&lt;li>WRITESET：使用 WriteSet 的方式判斷 Transaction 是否有衝突。&lt;/li>
&lt;li>WRITESET_SESSION：WRITESET 的基礎上保證同一個 session 內的 Transaction 不可並行。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_dependency_history_size" target="_blank" rel="noopener"
>binlog_transaction_dependency_history_size&lt;/a> (8.0 ~)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-history.png"
width="573"
height="281"
srcset="https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-history_hu_1415df38253b7d55.png 480w, https://FuweaY.github.io/p/mysql-mts/binlog-transaction-dependency-history_hu_fdc1f13a3e149985.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="203"
data-flex-basis="489px"
>&lt;/p>
&lt;p>WriteSet 會判斷 Transaction 之間是否衝突，因此需要將 commit 的 Transaction 修改的行 hash 後暫時保存在內存。&lt;/p>
&lt;p>此參數用來設定儲存的 hash 上限，超過此上限會清除先前的歷史紀錄。&lt;/p>
&lt;p>若 Source 性能有餘裕可以考慮提升此參數，進一步提高 Replica 的並行度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_transaction_write_set_extraction" target="_blank" rel="noopener"
>transaction_write_set_extraction&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/transaction-write-set-extraction.png"
width="573"
height="324"
srcset="https://FuweaY.github.io/p/mysql-mts/transaction-write-set-extraction_hu_788d0ffa134a8fe0.png 480w, https://FuweaY.github.io/p/mysql-mts/transaction-write-set-extraction_hu_ee47aa4a08fca84b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="176"
data-flex-basis="424px"
>&lt;/p>
&lt;p>設定 WriteSet 使用的 Hash 演算法。&lt;/p>
&lt;p>MySQL 5.7 預設為 OFF，MySQL 8.0.26 後棄用，一般不用特別調整。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="官方測試數據">官方測試數據
&lt;/h2>&lt;p>以下為官方使用SYSBENCH進行壓測的圖表，可以觀察到：&lt;/p>
&lt;ul>
&lt;li>在 Source 低並行率的情況，WRITESET 的機制下 Replica 仍舊能夠有良好的並行率。&lt;/li>
&lt;li>當 Source 並行率越高，COMMIT_ORDER 和 WriteSet 差距會縮小。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/official-1.png"
width="638"
height="369"
srcset="https://FuweaY.github.io/p/mysql-mts/official-1_hu_3b00e87c44e3ed28.png 480w, https://FuweaY.github.io/p/mysql-mts/official-1_hu_d342e907d68b98f.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="172"
data-flex-basis="414px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/official-2.png"
width="634"
height="364"
srcset="https://FuweaY.github.io/p/mysql-mts/official-2_hu_197b19f1142a4d1.png 480w, https://FuweaY.github.io/p/mysql-mts/official-2_hu_e3dc63fec2c378c2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="174"
data-flex-basis="418px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/official-3.png"
width="630"
height="339"
srcset="https://FuweaY.github.io/p/mysql-mts/official-3_hu_67c48b3d5247c90e.png 480w, https://FuweaY.github.io/p/mysql-mts/official-3_hu_44f1e486e24843f1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="446px"
>&lt;/p>
&lt;h2 id="親自測試">親自測試
&lt;/h2>&lt;p>環境：Mysql 8.0.12，測試前stop slave，待sysbench跑完後在start slave&lt;/p>
&lt;p>確認在performance_schema中，MTS相關的統計ENABLED皆有開啟(YES)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/setup-instruments.png"
width="618"
height="113"
srcset="https://FuweaY.github.io/p/mysql-mts/setup-instruments_hu_46e9f6547d7d3976.png 480w, https://FuweaY.github.io/p/mysql-mts/setup-instruments_hu_2e44d025aede9c80.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="546"
data-flex-basis="1312px"
>&lt;/p>
&lt;p>(*啟用或禁用transaction event的收集)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/setup-consumers.png"
width="604"
height="141"
srcset="https://FuweaY.github.io/p/mysql-mts/setup-consumers_hu_9796bfda0a9b4b1.png 480w, https://FuweaY.github.io/p/mysql-mts/setup-consumers_hu_b014b47d6902f199.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="428"
data-flex-basis="1028px"
>&lt;/p>
&lt;p>(分別為當前的transaction event，每個線程最近的transaction event，global(跨線程)最近的transaction event)&lt;/p>
&lt;p>查詢MTS並行度的語法&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">select thread_id,count_star
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from events_transactions_summary_by_thread_by_event_name
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">where thread_id in (
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">select thread_id
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">from replication_applier_status_by_worker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">OR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">USE test;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">CREATE VIEW rep_thread_count AS SELECT a.THREAD_ID AS THREAD_ID,a.COUNT_STAR AS COUNT_STAR
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">FROM performance_schema.events_transactions_summary_by_thread_by_event_name a
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">WHERE a.THREAD_ID in (SELECT b.THREAD_ID FROM performance_schema.replication_applier_status_by_worker b);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT SUM(COUNT_STAR) FROM rep_thread_count INTO @total;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SELECT 100*(COUNT_STAR/@total) AS thread_usage FROM rep_thread_count;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#replication_applier_status_by_worker可以查看replication各個線程的運作狀況
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#events_transactions_summary_by_thread_by_event_name彙總的每個線程的事件名稱，包含已關閉線程
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#透過replication...table找出正在運作的線程再到event...table找到他們的count_star(執行的transaction數量)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首次壓測以Threads 1 進行10分鐘壓測&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1.png"
width="735"
height="228"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1_hu_bf23ccaac58c4d23.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1_hu_f1aa00859d09101b.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="322"
data-flex-basis="773px"
>&lt;/p>
&lt;p>在commit_order下測試(即MySQL 5.7使用)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1.png"
width="552"
height="113"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1_hu_fed257d9318fbb9a.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1_hu_a778a8e65d8111cf.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="488"
data-flex-basis="1172px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1-result.png"
width="224"
height="135"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1-result_hu_f96a92895ed00c07.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-thread-1-result_hu_d62c32fadcef5314.png 1024w"
loading="lazy"
alt="commit_order 並行效率"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="398px"
>&lt;/p>
&lt;p>在WriteSet下測試(MySQL 8.0新方案)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1.png"
width="557"
height="114"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1_hu_56bd1ec0d29b6c37.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1_hu_82258c7637565e83.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="488"
data-flex-basis="1172px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-thread1-result.png"
width="231"
height="141"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-thread1-result_hu_301b577cfa94eab4.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-thread1-result_hu_67050ade438aac2b.png 1024w"
loading="lazy"
alt="writeSet 並行效率"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="393px"
>&lt;/p>
&lt;p>接著試試看Threads 128進行10分鐘壓測&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128.png"
width="720"
height="229"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128_hu_f8f6eac7cf91aa4.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128_hu_dc7f8ce4a44b7b75.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="314"
data-flex-basis="754px"
>&lt;/p>
&lt;p>在commit_order下測試(即MySQL 5.7使用)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1.png"
width="552"
height="113"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1_hu_fed257d9318fbb9a.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-commit-order-57-1_hu_a778a8e65d8111cf.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="488"
data-flex-basis="1172px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-commit-order-result.png"
width="211"
height="114"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-commit-order-result_hu_e0649ddfe29e882f.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-commit-order-result_hu_546283d58a856a6e.png 1024w"
loading="lazy"
alt="commit_order 並行效率"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="444px"
>&lt;/p>
&lt;p>在WriteSet下測試(MySQL 8.0新方案)&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1.png"
width="557"
height="114"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1_hu_56bd1ec0d29b6c37.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-writeSet-80-1_hu_82258c7637565e83.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="488"
data-flex-basis="1172px"
>&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-writeSet-result.png"
width="221"
height="142"
srcset="https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-writeSet-result_hu_34e16099ee1d33e6.png 480w, https://FuweaY.github.io/p/mysql-mts/sysbench-thread-128-writeSet-result_hu_cd73732064be7b1b.png 1024w"
loading="lazy"
alt="writeSet 並行效率"
class="gallery-image"
data-flex-grow="155"
data-flex-basis="373px"
>&lt;/p>
&lt;p>測試結果基本上和官方提供的差不多，主要是解決在Master低並行度的情況下，提高MTS的效率。&lt;/p>
&lt;h2 id="log">LOG
&lt;/h2>&lt;p>當開啟 MTS 且 log_error_verbosity = 3 (NOTE) 時，會在&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">2023-01-30T03:08:36.440821Z 6 [Note] [MY-010559] [Repl] Multi-threaded slave statistics for channel &amp;#39;&amp;#39;: seconds elapsed = 277; events assigned = 20795393; worker queues filled over overrun level = 0; waited due a Worker queue full = 0; waited due the total size = 0; waited at clock conflicts = 12923330700 waited (count) when Workers occupied = 0 waited when Workers occupied = 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="懶人包">懶人包
&lt;/h2>&lt;h3 id="mysql-575721-參數設定">MySQL 5.7~5.7.21 參數設定
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>Source (Master)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># 以下非必須，依據實際情況評估調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_group_commit_sync_delay = ?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_group_commit_sync_no_delay_count = ?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Replica (Slave)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># 推薦調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_parallel_workers = ?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_parallel_type = LOGICAL_CLOCK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_preserve_commit_order = ON
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="mysql-572280xx-參數設定">MySQL 5.7.22~8.0.XX 參數設定
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>Source (Master)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># 推薦調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_transaction_dependency_tracking = WRITESET_SESSION
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">transaction_write_set_extraction = XXHASH64
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 以下依據實際情況評估調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 優先調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_transaction_dependency_history_size = ?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 調整優先度低，因為退化回 commit order 時才有效，情境為：
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 1. 沒有 pk 或 uk
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 2. DDL 語句
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 3. Transaction 的更新包含 FK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 4. history 剛被清空
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 5. 同一個 session 的 Transaction (WRITESET_SESSION)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_group_commit_sync_delay = ?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">binlog_group_commit_sync_no_delay_count = ?
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>Replica (Slave)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"># 推薦調整
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_parallel_workers = ?
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_parallel_type = LOGICAL_CLOCK
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">slave_preserve_commit_order = ON
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h3 id="mts-效率確認">MTS 效率確認
&lt;/h3>&lt;p>調整後可以使用以下語法查看調整後 MTS 並行的效率，理想的情況下同一個 channel 的每個 sql thread 的 count_star 應該差不多：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">-- mysql 5.7 需先開啟以下設定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setup_consumers&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;yes&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;events_transactions%&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setup_instruments&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enabled&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;yes&amp;#39;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">where&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">like&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;transaction&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">-- mysql 5.7 需先開啟以上設定
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">replication_status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">CHANNEL_NAME&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">replication_status&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">enent_summary&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">count_star&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">events_transactions_summary_by_thread_by_event_name&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">enent_summary&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">INNER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">JOIN&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_applier_status_by_worker&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">AS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">replication_status&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">USING&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">thread_id&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="bug">BUG
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://bugs.mysql.com/bug.php?id=103636" target="_blank" rel="noopener"
>MySQL Bugs: #103636: Slave hangs with slave_preserve_commit_order On&lt;/a>&lt;/p>
&lt;p>說明：當 replica 設置了 replica_preserve_commit_order = 1 在高負載下長時間使用時，可能會用完 commit order sequence tickets 導致 applier 掛起 (hang) 並且無期限的持續等待 commit order queue。&lt;/p>
&lt;p>影響版本：MySQL 8.0.28 之前&lt;/p>
&lt;p>修復版本： MySQL 8.0.28&lt;/p>
&lt;p>github 資訊：&lt;a class="link" href="https://github.com/mysql/mysql-server/commit/f6bb5e7cc5e57f44c881a3f63ee507102c3e398d" target="_blank" rel="noopener"
>BUG#32891221 REPLICA HANGS WITH REPLICA_PRESERVE_COMMIT_ORDER ON · mysql/mysql-server@f6bb5e7 · GitHub&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="參考">參考
&lt;/h1>&lt;p>&lt;a class="link" href="http://mysql.taobao.org/monthly/2018/06/04/" target="_blank" rel="noopener"
>MySQL · 特性分析 · 8.0 WriteSet 并行复制&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/VicLiu/p/14653400.html" target="_blank" rel="noopener"
>速度提升5~10倍，基于WRITESET的MySQL并行复制 #M1013# - VicLW - 博客园 (cnblogs.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://blog.csdn.net/joy0921/article/details/80130768" target="_blank" rel="noopener"
>MySQL 5.7并行复制中并行的真正含义_仲培艺的博客-CSDN博客&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://mysql.taobao.org/monthly/2017/12/03/" target="_blank" rel="noopener"
>MySQL · 特性分析 · LOGICAL_CLOCK 并行复制原理及实现分析 (taobao.org)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=6314" target="_blank" rel="noopener"
>MySQL :: WL#6314: MTS: Prepared transactions slave parallel applier&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=7165" target="_blank" rel="noopener"
>MySQL :: WL#7165: MTS: Optimizing MTS scheduling by increasing the parallelization window on master&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://juejin.cn/post/6949470247673921567" target="_blank" rel="noopener"
>MySQL-组提交与并行复制 - 掘金 (juejin.cn)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=9556" target="_blank" rel="noopener"
>MySQL :: WL#9556: Writeset-based MTS dependency tracking on master&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://mysql.taobao.org/monthly/2017/08/01/" target="_blank" rel="noopener"
>MySQL · 引擎特性 · Group Replication内核解析 (taobao.org)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://opensource.actionsky.com/20190902-mysql/" target="_blank" rel="noopener"
>社区投稿 | 基于 WRITESET 的并行复制方式 (actionsky.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/blog-archive/improving-the-parallel-applier-with-writeset-based-dependency-tracking/" target="_blank" rel="noopener"
>MySQL :: Improving the Parallel Applier with Writeset-based Dependency Tracking&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/61336729" target="_blank" rel="noopener"
>MySQL Group Replication冲突检测机制再剖析 - 知乎 (zhihu.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/71913226" target="_blank" rel="noopener"
>深入浅析一致性模型之Causal Consistency - 知乎 (zhihu.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-features-transaction-inconsistencies.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 17.5.1.34 Replication and Transaction Inconsistencies&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/start-replica.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 13.4.2.8 START REPLICA Statement&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/show-replica-status.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 13.7.7.35 SHOW REPLICA STATUS Statement&lt;/a>&lt;/p></description></item><item><title>GTID</title><link>https://FuweaY.github.io/p/mysql-gtid/</link><pubDate>Thu, 27 Mar 2025 12:00:00 +0800</pubDate><guid>https://FuweaY.github.io/p/mysql-gtid/</guid><description>&lt;p>GTID 的全名是 Global Transaction identifier, MySQL 會為每一個 DML/DDL 操作都分配一個在整個 replicaion topology 都唯一的 GTID。&lt;/p>
&lt;p>在 replication 環境中，master 可以直接透過 GTID 定位發送 binlog 給 slave 不再需要指定 binlog 名稱和 postition 在同步上更為方便。此外 Slave 還會保留從 Master 同步過來的 Transaction 相同的 GTID，並持久化到 mysql.gtid_executed，搭配上 GTID 的自動跳過功能，保證了相同 GTID 的 Transaction 在同一個 instance 中只會執行一次，更加有助於 Replication 的一致性。&lt;/p>
&lt;h2 id="gtid-組成">GTID 組成
&lt;/h2>&lt;p>GTID 的組成為 source_id:transaction_id，範例 &lt;code>3E11FA47-71CA-11E1-9E33-C80AA9429562:23&lt;/code>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>source_id：該 DML/DDL 最原始執行的 server 其 UUID。&lt;/p>
&lt;p>在源碼中稱為 sid，會在 MySQL 啟動時從 auto.cnf 取得，如果沒有則根據啟動時間、線程的 LWP ID 及隨機內存地址生成後並記錄在 auto.cnf 中。&lt;/p>
&lt;p>注意：也就是說如果刪除現有的 auto.cnf 會在下次啟動時產生一個不同的 server uuid。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>transaction_id：原始 server 為該 DML/DDL 操作分配的唯一序列號，該序列號是順序遞增的。&lt;/p>
&lt;p>在源碼中稱為 gno 會在 Transaction 進入 Flush 階段中生成，MySQL 內部維護了一個全局變量 next_free_gno 的計數來生成 gno。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="gtid-life-cycle">GTID Life cycle
&lt;/h2>&lt;p>以下以 MySQL 8.0.17 以上來說明&lt;/p>
&lt;ol>
&lt;li>
&lt;p>當 Transaction 在 Master 上執行時，會在 commit 過程中的 Flush 階段生成 GTID 。&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-step.jpg"
width="2000"
height="734"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-step_hu_314c6c6b0a235188.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-step_hu_cd0c8151a222e9ad.jpg 1024w"
loading="lazy"
alt="gtid-step"
class="gallery-image"
data-flex-grow="272"
data-flex-basis="653px"
>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當分配 GTID 之後會將 Transaction 和其對應的 GTID 一起寫入 binlog (尚未進入 sync 階段進行 fsync 因此只是寫入 OS cache) 同時更新 mysql.gtid_executed 表及 @@GLOBAL.gtid_executed 變量。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 sync_binlog ≠ 1 時，就在 Flush 階段將 binlog 寫入 OS cache 後發送 binlog event 給 slave。&lt;/p>
&lt;p>當 sync_binlog = 1 時，在 sync 階段 fsycn 到 disk 後才發送 binlog event 給 slave。&lt;/p>
&lt;p>因此當 sync_binlog ≠ 1 時，當 Master crash 時可能導致 Slave 進度大於 Master。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Master 的 dump 線程將 binlog event 傳送給 Slave 保存至 relay log。&lt;/p>
&lt;ul>
&lt;li>詳細過程
&lt;ol>
&lt;li>在 Slave 的 IO_Thread 建立連線時，會將 &lt;code>Retrieved_Gtid_Set&lt;/code> 和 &lt;code>Executed_Gtid_Set&lt;/code>的並集 (UNION) 及自己的 server_id 發送給 Master。&lt;/li>
&lt;li>Master 確認自己的 &lt;code>gtid_purged&lt;/code> 是否為 Slave 發送的子集，以此來檢查 master 的 binlog 尚未 purge。&lt;/li>
&lt;li>Master 判斷 Slave 有哪些 GTID 還沒執行，並發送對應的 binlog 給 Slave。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Slave 從 relay log 讀取 GTID，並將 gtid_next 設為該 GTID，並判斷以下：&lt;/p>
&lt;ul>
&lt;li>從 &lt;code>@@GLOBAL.gtid_owned&lt;/code> 中確認沒有其他線程正在使用該 GTID，保證一次只有一個線程在處理該 GTID。&lt;/li>
&lt;li>從 &lt;code>@@GLOBAL.gtid_executed&lt;/code> 中確認該 GTID 是否已經應用過。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如果該 GTID 尚未被被應用，則在 Slave 應用該 Event 並維持該 Event 在 Master 上的 GTID，同時更新 mysql.gtid_executed 表及 @@GLOBAL.gtid_executed 變量。若有開啟 log_slave_update 則也寫入 binlog。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>在 8.0.17 (含 5.7 所有版本) 之前 mysql.gtid_executed 並不總是及時更新：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>當 &lt;code>log_bin = OFF&lt;/code> 或者 &lt;code>log_slave_update = OFF&lt;/code> 時，則 transaction 和 mysql.gtid_executed 會一起 commit 或 rollback。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 slave &lt;code>log_bin = ON&lt;/code> 且 &lt;code>log_slave_update = ON&lt;/code> 時 (注意：如果是 master &lt;code>log_bin = ON&lt;/code> 也適用)， 每當 binlog rotate 或者 server 關閉時，才會將先前 binlog 的所有 transaction gtid 寫入 mysql.gtid_executed 表。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 server crash 時，會在 crash recovery 時將 binlog 中的 GTID 添加到 mysql.gtid_executed 表。&lt;/p>
&lt;p>注意：當開啟時 log_bin = OFF 時，會無法恢復 GTID 導致無法啟動 replication。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>會使用每次 Transaction commit 時更新的 @@GLOBAL.gtid_executed 來表示 server 的 GTID 狀態，而不是使用 mysql.gtid_executed 表(因為不會即時更新)。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因為以上行為當開啟 gtid 模式且 log_slave_update = ON 時，必須要同時設置 sync_binlog = 1 &amp;amp; innodb_flush_log_at_trx_commit = 1，否則會導致 relication 在 OS crash 時發生問題。&lt;/p>
&lt;p>從 8.0.17 開始為了實現 clone 功能 (&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=9211" target="_blank" rel="noopener"
>WL#9211&lt;/a>) 更改了此行為，不論如何設置 mysql.gtid_executed 表總是和對應的 Event 一起 commit (rollback) 。&lt;/p>
&lt;h2 id="mysqlgtid_execute-表">mysql.gtid_execute 表
&lt;/h2>&lt;p>設計的初衷是用於當 slave 未開啟 binlog 或者是 &lt;code>log_slave_update = OFF&lt;/code> 時，或者是當 binlog 丟失時能夠保留 GTID 的狀態，因此會在這張表中持久化已經執行的 GTID SET。&lt;/p>
&lt;aside>
💡 RESET MASTER 會清空此表
&lt;/aside>
&lt;h3 id="壓縮">壓縮
&lt;/h3>&lt;p>隨著時間推移 mysql.gtid_executed 表會有許多筆資料：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">+--------------------------------------+----------------+--------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| source_uuid | interval_start | interval_end |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">|--------------------------------------+----------------+--------------|
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37 | 37 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38 | 38 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39 | 39 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40 | 40 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41 | 41 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42 | 42 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43 | 43 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+--------------------------------------+----------------+--------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>為了節省空間，MySQL 會定期壓縮 mysql.gtid_executed 表，壓縮的方式如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">+--------------------------------------+----------------+--------------+
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| source_uuid | interval_start | interval_end |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">|--------------------------------------+----------------+--------------|
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37 | 43 |
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">+--------------------------------------+----------------+--------------+
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>啟用 binlog 時，當發生 binlog rotation 時會壓縮 mysql.gtid_executed 表。&lt;/p>
&lt;p>當禁用 binlog 時會依據 &lt;a class="link" href="GTID%20903c4e34f0cc474ea92f3368b7d552de.md" >gtid_executed_compression_period&lt;/a> 的值決定壓縮的時機點，每當處理 N 個 Transaction 後會喚醒壓縮線程 (thread/sql/compress_gtid_table) 壓縮 mysql.gtid_executed 表。&lt;/p>
&lt;p>在 8.0.17 之前預設值為 1000，表示每 1000 個 Transaction 進行壓縮，在該版本之前不建議在關閉 binlog 時設定為 0，這將會增加所需的 disk 空間。&lt;/p>
&lt;p>從 8.0.17 開始建議設置為 0 (8.0.23 預設值)，這是因為從該版本開始 InnoDB 的 Transaction 寫入會由另一個 innodb/clone_gtid_thread 線程來控制寫入和壓縮， compress_gtid_table 線程會干擾其作業並降低速度。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">threads&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">WHERE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">NAME&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;%gtid%&amp;#39;&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">***************************&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">***************************&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">THREAD_ID&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">26&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">NAME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">thread&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="k">sql&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">compress_gtid_table&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">TYPE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">FOREGROUND&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_ID&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_USER&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_HOST&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_DB&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">PROCESSLIST_COMMAND&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Daemon&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_TIME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1509&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_STATE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Suspending&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSLIST_INFO&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PARENT_THREAD_ID&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">ROLE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">INSTRUMENTED&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">YES&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">HISTORY&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">YES&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">CONNECTION_TYPE&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">NULL&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">THREAD_OS_ID&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">18677&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="系統變量-gtid_executed-和-gtid_purged-的初始化與更新">系統變量 gtid_executed 和 gtid_purged 的初始化與更新
&lt;/h2>&lt;h3 id="初始化">初始化
&lt;/h3>&lt;p>每個 binlog 的開頭都有 &lt;code>Previous-GTIDs&lt;/code>：這是由上一個 binlog 文件的 &lt;code>Previous-GTIDs&lt;/code> 和上一個 binlog 文件所有的 Transaction GTID 組成。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">~ -&amp;gt; mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -vvv mysql-bin.000004
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#230217 8:17:55 server id 1 end_log_pos 125 CRC32 0xa9000aca Start: binlog v 4, server v 8.0.21 created 230217 8:17:55 at startup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ROLLBACK/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># at 125
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#230217 8:17:55 server id 1 end_log_pos 196 CRC32 0xf3d86d46 Previous-GTIDs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 6c3c06b0-ae9b-11ed-a26c-0242ac1d0002:1-3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.GTID_NEXT= &amp;#39;6c3c06b0-ae9b-11ed-a26c-0242ac1d0002:4&amp;#39;/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.GTID_NEXT= &amp;#39;6c3c06b0-ae9b-11ed-a26c-0242ac1d0002:5&amp;#39;/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># End of log file
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">~ -&amp;gt; mysql-docker $ mysqlbinlog --no-defaults --base64-output=DECODE-ROWS -vvv mysql-bin.000005
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#230217 8:19:12 server id 1 end_log_pos 125 CRC32 0xd5587e96 Start: binlog v 4, server v 8.0.21 created 230217 8:19:12 at startup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># Warning: this binlog is either in use or was not closed properly.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">ROLLBACK/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># at 125
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#230217 8:19:12 server id 1 end_log_pos 196 CRC32 0x2416aa2b Previous-GTIDs
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># 6c3c06b0-ae9b-11ed-a26c-0242ac1d0002:1-5
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>gtid_executed 和 gtid_purged 這 2 個系統變量在 MySQL 啟動時會透過 binlog 計算進行初始化：&lt;/p>
&lt;ul>
&lt;li>gtid_executed：由最新的 binlog 文件的 &lt;code>Previous-GTIDs&lt;/code>、最新的 binlog 文件所有的 Transaction GTID、mysql.gtid_excuted 並集 (UNION) 計算得出。&lt;/li>
&lt;li>gtid_purged：
&lt;ol>
&lt;li>
&lt;p>將最新的 binlog 文件的 &lt;code>Previous-GTIDs&lt;/code>、最新的 binlog 文件所有的 Transaction GTID 相加，計算出 gtids_in_binlog (表示曾出現在 binlog 的所有 gtid)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>將 gtids_in_binlog 減去最舊的 binlog 文件的 &lt;code>Previous-GTIDs&lt;/code>，計算出 gtids_in_binlog_not_purged (表示所在的 binlog 尚未被清除的 gtid)。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>將 gtid_executed 減去 gtids_in_binlog_not_purged，得出在 server 上執行過但 binlog 已被清楚的 GTID SET。&lt;/p>
&lt;p>由上計算得知如果 binlog 未開啟時，gtid_purged = gtid_executed 。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h3 id="更新">更新
&lt;/h3>&lt;ul>
&lt;li>gtid_executed：
&lt;ul>
&lt;li>會在 Transaction commit 的時候同步更新。&lt;/li>
&lt;li>set global gtid_purged，設為原先 gtid_execute 和新設置 gtid_purged 的並集 (UNION)。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>gtid_purged：
&lt;ul>
&lt;li>當 log_slave_updates = OFF 時，會在 Transaction commit 的時候同步更新。&lt;/li>
&lt;li>當 Master 開啟 binlog 時，當執行 purge binary logs 或 binlog 超過 expire_logs_days (binlog_expire_logs_seconds) 的設置時，觸發清除 binlog 的動作更新。&lt;/li>
&lt;li>當 Slave 開啟 log_slave_updates，當執行 purge binary logs 或 binlog 超過 expire_logs_days (binlog_expire_logs_seconds) 的設置時，觸發清除 binlog 的動作更新。&lt;/li>
&lt;li>當 Slave 關閉 log_slave_updates ，會在 Transaction commit 的時候同步更新。&lt;/li>
&lt;li>set global gtid_purged，被設定或增加指定 gtid set。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>共同：
&lt;ul>
&lt;li>RESET MASTER 時設為空值。&lt;/li>
&lt;li>在 MySQL 啟動時初始化。&lt;/li>
&lt;li>Master 未開啟 binlog 時，因為不會產生 GTID，因此不會有任何更新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="gtid-相關變量">GTID 相關變量
&lt;/h2>&lt;h3 id="gtid_mode">gtid_mode
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-mode.jpg"
width="572"
height="315"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-mode_hu_5b6a4a39e8b81977.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-mode_hu_cbc4da12f86538a1.jpg 1024w"
loading="lazy"
alt="gtid_mode"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="435px"
>&lt;/p>
&lt;p>控制是否開啟 GTID 功能。&lt;/p>
&lt;p>可以設置為以下值：&lt;/p>
&lt;ul>
&lt;li>OFF：所有新的或回放的 Transaction 都是 anonymous。&lt;/li>
&lt;li>OFF_PERMISSIVE：所有新的 Transaction 都是 anonymous，但回放的 Transaction 可以是 anonymous 也可以包含 GTID。&lt;/li>
&lt;li>ON_PERMISSIVE：所有新的 Transaction 都包含 GTID，但回放的 Transaction 可以是 anonymous 也可以包含 GTID。&lt;/li>
&lt;li>ON：必須同時設置 enforce_gtid_consistency = ON。&lt;/li>
&lt;/ul>
&lt;p>在修改 gtid_mode 時一次只能變更為上一個或下一個值，例如：原先設置為 OFF_PERMISSIVE 則只能設置為 OFF 或 ON_PERMISSIVE。&lt;/p>
&lt;h3 id="enforce_gtid_consistency">enforce_gtid_consistency
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/enforce-gtid-consistency.jpg"
width="576"
height="296"
srcset="https://FuweaY.github.io/p/mysql-gtid/enforce-gtid-consistency_hu_70752c55119992ca.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/enforce-gtid-consistency_hu_4a8af9082bbea885.jpg 1024w"
loading="lazy"
alt="enforce_gtid_consistency"
class="gallery-image"
data-flex-grow="194"
data-flex-basis="467px"
>&lt;/p>
&lt;p>控制是否允許違反 GTID 一致性的語句執行，必須設置為 ON 才能設置 gtid_mode = ON。&lt;/p>
&lt;p>可以設置為以下值：&lt;/p>
&lt;ul>
&lt;li>OFF (0)：允許所有違反 GTID 一致性的語句執行。&lt;/li>
&lt;li>ON (1)：不允許任何違反 GTID 一致性的語句執行。&lt;/li>
&lt;li>WARN (2)：允許所有違反 GTID 一致性的語句執行，但會產生 warning。&lt;/li>
&lt;/ul>
&lt;p>只有在語句寫入 binlog 時才會檢查，也就是未開啟 binlog 或當語句被 filter 過濾時不會檢查。&lt;/p>
&lt;p>違反 GTID 一致性的語句可以參考 &lt;a class="link" href="GTID%20903c4e34f0cc474ea92f3368b7d552de.md" >GTID 限制&lt;/a> 章節。&lt;/p>
&lt;h3 id="gtid_next">gtid_next
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-next.jpg"
width="518"
height="262"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-next_hu_7927395141f577f7.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-next_hu_8dbd23ef2d81faf4.jpg 1024w"
loading="lazy"
alt="gtid-next"
class="gallery-image"
data-flex-grow="197"
data-flex-basis="474px"
>&lt;/p>
&lt;p>gtid_next 用於指定如何獲取下一個 GTID。&lt;/p>
&lt;p>gtid_next 可以設為以下值：&lt;/p>
&lt;ul>
&lt;li>AUTOMATIC：使用下一個自動生成的 GTID。&lt;/li>
&lt;li>ANONYMOUS：Transaction 沒有 GTID，只有 gtid_mode = OFF 時才能設置的值。&lt;/li>
&lt;li>指定 GTID&lt;/li>
&lt;/ul>
&lt;p>將 gtid_next 設置為指定 GTID 後，需要在 Transaction commit 或 rollback 後，必須在執行其他語句之前再次顯式的 SET GTID_NEXT：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gtid_next&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;08d3c091-addb-11ed-8959-0242ac1c0002:5&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">begin&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">rollback&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">01&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">insert&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">into&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">test&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">values&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">ERROR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1837&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">HY000&lt;/span>&lt;span class="p">):&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">When&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">SESSION&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">is&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">to&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">you&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">must&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">explicitly&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">it&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">to&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">different&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">after&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">or&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ROLLBACK&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Please&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">check&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">variable&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">manual&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">page&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">detailed&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">explanation&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Current&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">SESSION&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">is&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;08d3c091-addb-11ed-8959-0242ac1c0002:5&amp;#39;&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="gtid_owned">gtid_owned
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-owned.jpg"
width="518"
height="182"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-owned_hu_787a44bbcfe7e1dd.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-owned_hu_1154763dda1a99ae.jpg 1024w"
loading="lazy"
alt="gtid_owned"
class="gallery-image"
data-flex-grow="284"
data-flex-basis="683px"
>&lt;/p>
&lt;p>此為 read-only 的變量，根據 Scope 的不同有不同意思：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Global：列出 server 正在使用的所有 GTID 以及擁有該 GTID 的線程 ID。&lt;/p>
&lt;p>主要用於開啟 MTS 時，檢查是否有其他 applier 已經在應用該 GTID，避免同一個 GTID 在同時被多個線程同時處理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Session：列出該 session 使用中的 GTID。&lt;/p>
&lt;p>當手動設置 gtid_next 為指定 GTID 時，可以在 Transaction 在 commit (rollback) 之前透過 gtid_owned 觀察到此設置。&lt;/p>
&lt;p>當 gtid_next = AUTOMATIC 時，只有在 Trasnsaction commit 時能從 gtid_next 中短暫觀察到，其餘時候會是空值。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="gtid_executed">gtid_executed
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-executed.jpg"
width="517"
height="185"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-executed_hu_f490155faa0e6442.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-executed_hu_8a3533392ba7cd36.jpg 1024w"
loading="lazy"
alt="gtid_executed"
class="gallery-image"
data-flex-grow="279"
data-flex-basis="670px"
>&lt;/p>
&lt;p>此為 read-only 的變量，指的是所有該 server 已經執行的 GTID，也會等同於 SHOW MASTER ( | SLAVE ) STATUS 中的 Executed_Gtid_Set 值。&lt;/p>
&lt;p>&lt;strong>當執行 RESET MASTER 時會將 gtid_executed 設置為空值。&lt;/strong>&lt;/p>
&lt;p>gtid_executed 的 Gtid_Set 會包含 gtid_purged 的 Gtid_Set ，因此在任何時候執行 GTID_SUBTRACT(@@GLOBAL.gtid_executed, @@GLOBAL.gtid_purged) 可以得到未清除的 binlog 中所有的 GTID。&lt;/p>
&lt;h3 id="gtid_purged">gtid_purged
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-purged.jpg"
width="518"
height="184"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-purged_hu_e55e1429d397617b.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-purged_hu_4fd9f914a82e8f0d.jpg 1024w"
loading="lazy"
alt="gtid_purged"
class="gallery-image"
data-flex-grow="281"
data-flex-basis="675px"
>&lt;/p>
&lt;p>此變量表示在 server 上已經執行，但是對應的 binlog 已經被清除的 GTID SET，因此 gtid_purged 為 gtid_executed 的子集。&lt;/p>
&lt;p>以下情況的 GTID 會包含在 gtid_purged：&lt;/p>
&lt;ul>
&lt;li>當 slave 未開啟 log_slave_updates 時，已經回放的 Transaction 的 GTID。&lt;/li>
&lt;li>包含該 GTID 的 binlog 已經被清除。&lt;/li>
&lt;li>透過 SET @@GLOBAL.gtid_purged 來顯示設置。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>當執行 RESET MASTER 時會將 gtid_purged 設置為空值。&lt;/strong>&lt;/p>
&lt;p>可以透過 SET @@GLOBAL.gtid_purged 來顯示設定，有以下兩種方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>將 gtid_purged 變更為指定的 GTID SET：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">gtid_purged&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;gtid_set&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>經過此設置後 gtid_purged 等於 gtid_set，且 gtid_executed 值 (mysql.gtid_executed) 等於 gtid_executed 原本的值和 gtid_set 的並集 (UNION)。&lt;/p>
&lt;p>gtid_set 限制：&lt;/p>
&lt;ul>
&lt;li>指定的 gtid_set 必須是 gtid_purged 當前值的超集 (superset)，也就是新設置的 GTID SET 必須包含原本的 gtid_purged。&lt;/li>
&lt;li>指定的 gtid_set不得和 gtid_subtract(gtid_executed,gtid_purged) 相交，也就是新設置的 GTID SET 不能包含在 gtid_executed 中尚未被清除的值。&lt;/li>
&lt;li>指定的 gtid_set 不能包含 @@global.gtid_owned 中的任何 GTID，也就是不能包含當前 server 正在執行的 gtid。&lt;/li>
&lt;/ul>
&lt;p>用途範例：使用 mysqldump 還原 slave 上損壞的表，因為備份檔和原先 slave 的 gtid 有重疊，因此可以使用使方式進行 gtid_purged 的設置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>為 gtid_purged append (新增) 指定的 GTID SET&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">gtid_purged&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;+gtid_set&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>經過此設置後 gtid_executed (包含 mysql.gtid_executed)、gtid_purged 會新增 gtid_set。&lt;/p>
&lt;p>gtid_set 限制：&lt;/p>
&lt;ul>
&lt;li>gtid_set 不得與 gtid_executed 的當前值相交，也就是新附加上去的 GTID SET 不能包含在 gtid_executed 和 gtid_purged 中的 GTID。&lt;/li>
&lt;li>指定的 gtid_set 不能包含 @@global.gtid_owned 中的任何 GTID，也就是不能包含當前 server 正在執行的 gtid。&lt;/li>
&lt;/ul>
&lt;p>用途範例：為了配置多個 channel 的 salve，將來自不同 master 的備份還原到同一個 server，因為兩者的 Transaction 不相交，因此使用 append 的方式更新 gtid_purged。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>注意：在 MySQL 5.7 中只能直接變更成指定的 GTID SET，無法使用 append 的方式，且只有當 gtid_executed 為空 (也就是 gtid_purged 值也為空) 時才可以更新 gtid_purged 的值&lt;/p>
&lt;h3 id="gtid_executed_compression_period">gtid_executed_compression_period
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/gtid-executed-compression-period.jpg"
width="575"
height="309"
srcset="https://FuweaY.github.io/p/mysql-gtid/gtid-executed-compression-period_hu_44a296a498aac305.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/gtid-executed-compression-period_hu_689a93edd88a4b11.jpg 1024w"
loading="lazy"
alt="gtid_executed_compression_period"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="446px"
>&lt;/p>
&lt;p>此設置只有禁用 binlog 才有效，每當處理 N 個 Transaction 後會喚醒線程壓縮 mysql.gtid_executed 表，當設置為 0 時表示壓縮不固定執行，而是根據需要進行壓縮。&lt;/p>
&lt;p>當啟用 binlog 時，不會使用此設置，而是當 binlog rotation 時才會壓縮 mysql.gtid_executed 表。&lt;/p>
&lt;h3 id="binlog_gtid_simple_recovery">binlog_gtid_simple_recovery
&lt;/h3>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-gtid/binlog-gtid-simple-recovery.jpg"
width="573"
height="217"
srcset="https://FuweaY.github.io/p/mysql-gtid/binlog-gtid-simple-recovery_hu_79291e933c1334db.jpg 480w, https://FuweaY.github.io/p/mysql-gtid/binlog-gtid-simple-recovery_hu_e2c5b3fbe2aaea57.jpg 1024w"
loading="lazy"
alt="binlog_gtid_simple_recovery"
class="gallery-image"
data-flex-grow="264"
data-flex-basis="633px"
>&lt;/p>
&lt;p>控制 MySQL 啟動時從 binlog 尋找 GTID 的行為。&lt;/p>
&lt;h2 id="gtid-限制">GTID 限制
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>不能在一個 Transaction 中同時涉及 nontransactional 儲存引擎 (例如：MyISAM) 和 transactional儲存引擎 (例如：InnoDB) 的表進行更新。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持 sql_slave_skip_counter，除非 slave 在 CHANGE MASTER 時包含了 ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS 才能使用 sql_slave_skip_counter。&lt;/p>
&lt;p>備註：ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS 該功能用來在未開啟 GTID 的 Master 和開啟 GTID 的 Slave 進行 Replication，且會為 Slave 執行的 Transaction 生成 GTID。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不支持 CHANGE MASTER 時使用 IGNORE_SERVER_IDS 選項。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 MySQL 8.0.21 之前，不支援 &lt;strong>CREATE TABLE &amp;hellip; SELECT&lt;/strong> 語句，因為該語句基於 STATEMENT 會產生一個 GTID，但ROW 格式紀錄會產生 2 個 GTID，這會導致無法正確處理 Transaction。&lt;/p>
&lt;p>在 MySQL 8.0.21 之後，因為支持 atomic (原子) DDL 操作，因此不再有該限制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 MySQL 8.0.13 之前不能在 Transaction、Procedures、Functions 和 Triggers 內都不能使用 CREATE/DROP TEMPORARY TABLE，只能在非 Transaction 內且 autocommit = 1 時才能使用。&lt;/p>
&lt;p>從 MySQL 8.0.13 開始，當 binlog_format 設置為 ROW 或 MIXED 時，在使用 GTID 時允許使用 CREATE/DROP TEMPORARY TABLE，因為這些語句將不會寫入 binlog。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 MySQL 8.0.16 之前，不能在 mysql_upgrade 中加上 &lt;code>--write-binlog&lt;/code> 選項。&lt;/p>
&lt;p>從 MySQL 8.0.16 開始，執行 mysql_upgrade 期間總是會自動禁用 binlog，因此沒有問題。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="在線開啟-gtid">在線開啟 GTID
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>在所有的 MySQL server 設置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ENFORCE_GTID_CONSISTENCY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">WARN&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>設置後讓 MySQL 接受正常的操作，並在期間從 Error Log 確認是否有出現 GTID 不支持的 Query，並對其進行修正。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 設置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ENFORCE_GTID_CONSISTENCY&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>設置後所有 GTID 不支持的操作都將被拒絕。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 設置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GTID_MODE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OFF_PERMISSIVE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>表示 Master 生成的是 ANONYMOUS Transaction，Slave 可以應用 ANONYMOUS 、GTID Transaction。&lt;/p>
&lt;p>注意務必在所有 server 都設置此步驟後，才執行下一步驟。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 設置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GTID_MODE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">ON_PERMISSIVE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>表示 Master 生成的是 GTID Transaction，Slave 可以應用 ANONYMOUS 、GTID Transaction。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 中確定以下變量為 0：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">LIKE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;ONGOING_ANONYMOUS_TRANSACTION_COUNT&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>該值就是尚未 commit ANONYMOUS Transaction 數量，因此必須確認該值為 0 表示沒有 ANONYMOUS Transaction 都是 GTID Transaction 。&lt;/p>
&lt;ul>
&lt;li>ONGOING_ANONYMOUS_TRANSACTION_COUNT 增減的時機
&lt;ul>
&lt;li>在 Master 上
&lt;ul>
&lt;li>增加：當 FLUSH 階段分配 GTID 時，如果為 ANONYMOUS Transaction 則增加該計數。&lt;/li>
&lt;li>減少：在 COMMIT 階段 InnoDB COMMIT 之後會減少該計數。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 Slave 上
&lt;ul>
&lt;li>增加：當 SQL Tread 應用到 ANONYMOUS Transaction 則增加該計數。&lt;/li>
&lt;li>減少：當 SQL Tread 執行 InnoDB COMMIT 之後會減少該計數。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>當 ONGOING_ANONYMOUS_TRANSACTION_COUNT 都為 0 的時候，確認所有 slave 都有執行過對應 master binlog 的 position，並非指不能有延遲只是要確保所有的 ANONYMOUS Transaction 都已經被執行。&lt;/p>
&lt;p>在 Master 以下指令， 獲取 Master binlog、Master position&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">獲取&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Master&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">binlog&lt;/span>&lt;span class="err">、&lt;/span>&lt;span class="n">Master&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">position&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SHOW&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">STATUS&lt;/span>&lt;span class="err">\&lt;/span>&lt;span class="k">G&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在 Slave 執行以下指令，確認 slave 是否已執行 master 對應的 binlog 及 position&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">確認&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">slave&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">是否已執行&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">master&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">對應的&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">binlog&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">及&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">position&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER_POS_WAIT&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">file&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">position&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>如果 binlog 有用於 replication 以外的用途 (例如：基於時間點的備份和恢復)，請在此時確保包含 ANONYMOUS Transaction 的 Binlog 已不再需要。&lt;/p>
&lt;p>例如：在第 6 步完成後，在備份機上執行 flush logs 後進行備份。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 設置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">@@&lt;/span>&lt;span class="k">GLOBAL&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GTID_MODE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在所有的 MySQL server 的 my.cnf 中添加&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">gtid_mode&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">enforce_gtid_consistency&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="k">ON&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在 slave 執行 change master&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">STOP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SLAVE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CHANNEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;channel&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">CHANGE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">TO&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">MASTER_AUTO_POSITION&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CHANNEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;channel&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">START&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SLAVE&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="k">FOR&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">CHANNEL&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;channel&amp;#39;&lt;/span>&lt;span class="p">];&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="gtid-中的維運">GTID 中的維運
&lt;/h2>&lt;h3 id="show-slave-status">SHOW SLAVE STATUS
&lt;/h3>&lt;p>在開啟 GTID 後，透過 SHOW SLAVE STATUS 會增加以下資訊：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Retrieved_Gtid_Set：Slave 從 Master 收到的 GTID SET，也就是 IO_Thread 已經接收到的 GTID。&lt;/p>
&lt;p>當 relay-log-recovery = 1 或 RESET SLAVE 或 CHANGE MASTER 時會被清空。&lt;/p>
&lt;p>當 relay-log-recovery = 0 時，在 MySQL 重啟時會從 relay log 中掃描確認。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Executed_Gtid_Set：Slave 已經執行的 GTID SET (包含直接在 slave 上執行的語句)，等同於 gtid_executed。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="清除-gtid-歷史紀錄">清除 GTID 歷史紀錄
&lt;/h3>&lt;p>如果要完全清楚 GTID 歷史紀錄可以使用 RESET MASTER 指令。&lt;/p>
&lt;p>執行前務必備份 binlog、binlog index 文件，獲取並且保存 gtid_executed 變量。&lt;/p>
&lt;p>RESET MASTER 執行以下操作：&lt;/p>
&lt;ul>
&lt;li>gtid_purged 被設為空字串。&lt;/li>
&lt;li>gtid_executed 被設為空字串。&lt;/li>
&lt;li>mysql.gtid_executed 表被清空。&lt;/li>
&lt;li>刪除現有 binlog，並清除 binlog index 文件。&lt;/li>
&lt;/ul>
&lt;p>注意只有 RESET MSTER 會重置 GTID 的歷史紀錄，RESET SLAVE 沒有任何影響。&lt;/p>
&lt;h3 id="跳過一個-transaction">跳過一個 Transaction
&lt;/h3>&lt;p>當有 Transaction 在 SQL_Thread 中發生錯誤時，可以透過 performance_schema 中的&lt;code>replication_applier_status_by_worker&lt;/code> 該表中的 APPLYING_TRANSACTION 欄位獲取該 Transaction 的 GTID。&lt;/p>
&lt;p>當確認要跳過該失敗的 Transaction 時，在 GTID 模式下傳統的 sql_slave_skip_counter 不能使用，而是要使用以下方式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">STOP&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SLAVE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">將&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">設為要跳過的&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;aaa-bbb-ccc-ddd:N&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">#&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">將該&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Transaction&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="err">設為一個空&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">Transaction&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">BEGIN&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">COMMIT&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">SET&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">GTID_NEXT&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;AUTOMATIC&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">START&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">SLAVE&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上述步驟後會將要跳過的 GTID 設為一個空的 Transaction 並將其應用，此時 slave 會認為自己已執行完畢該 GTID，因此可以將 GTID_NEXT 設回 &lt;code>AUTOMATIC&lt;/code> 讓 slave 自行找到下一個要執行的 GTID。&lt;/p>
&lt;p>如果是有多個 channel 的 slave，commit 一個空的 Transaction 時不需要指定 channel，只有在 START SLAVE 才需要指定 channel 名稱。&lt;/p>
&lt;p>注意：此方法不適用 ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS&lt;/p>
&lt;p>參考&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-administration-skip.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 17.1.7.3 Skipping Transactions&lt;/a>&lt;/p>
&lt;h3 id="mysqldump-行為的變化">mysqldump 行為的變化
&lt;/h3>&lt;p>mysqldump 在開啟 gtid 後預設的 dump 行為會有所改變，這是因為 &lt;code>--set-gtid-purged&lt;/code> 該選項預設值的影響：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>AUTO (預設值)：在開啟 GTID (gtid_mode = ON) 時自動設為 ON，在未開啟 GTID (gtid_mode = OFF) 時自動設為 OFF。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ON：備份檔中會包含 &lt;code>gtid_purgrd&lt;/code> 且會添加 &lt;code>sql_log_bin = 0&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">SET @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.SQL_LOG_BIN= 0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">-- GTID state at the beginning of the backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">--
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@GLOBAL.GTID_PURGED=&amp;#39;42fe5059-32a7-11e6-9d29-000c29fcecda:1&amp;#39;;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>這樣的設置下會有以下結果：&lt;/p>
&lt;ul>
&lt;li>設置 &lt;code>sql_log_bin = 0&lt;/code>：關閉了 binlog 紀錄，因此還原的機器不會生成新的 GTID。&lt;/li>
&lt;li>設置 &lt;code>gtid_purgrd&lt;/code> ：同時也會同時修改 &lt;code>gtid_executed&lt;/code> 值及 &lt;code>mysql.gtid_executed&lt;/code> 表。&lt;/li>
&lt;/ul>
&lt;p>此設置適合用於還原一個 slave 接上備份檔來源的 replication topology。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>OFF：備份檔中不會包含 &lt;code>gtid_purgrd&lt;/code> 且不會添加 &lt;code>sql_log_bin = 0&lt;/code>，此設置用於未開啟 GTID 的 MySQL 或是適合於還原一個和原本 replication topology 無關的新 master。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>COMMENTED：從 8.0.17 開始可用，備份檔中會添加 &lt;code>sql_log_bin = 0&lt;/code>，並在備份中用註解的方式記錄 &lt;code>gtid_purgrd&lt;/code>。此方式較為彈性適合，用於不需生成新的 gtid (基本上表示會在同一個 replication topology) 但情境較為複雜的需要自行調整 &lt;code>gtid_purgrd&lt;/code> 時，例如：還原後的機器會有多個 channel。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>因此當開啟 gtid 後在使用 mysqldump 時需要注意 &lt;code>--set-gtid-purged&lt;/code> 的設置：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>當 &lt;code>gtid_mode = OFF&lt;/code> 未開啟 GTID 時，可以不需要調整該參數或顯式指定為 OFF。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 &lt;code>gtid_mode = ON&lt;/code> 開啟 GTID 時，若用於還原到同一個 replication topology 的機器，例如：新增一個 slave、為 slave 補上在 master binlog 上已經 purge 的資料……等，這時候就可以保留預設值或顯式指定為 &lt;code>ON&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 &lt;code>gtid_mode = ON&lt;/code> 開啟 GTID 時，但還原到不同 replication topology 的機器或需要生成新的 GTID，例如：還原成一個新的 master……等，這時候就可以設置為 &lt;code>OFF&lt;/code>。&lt;/p>
&lt;p>注意：如果在同一個 replication topology 中設置 OFF，除了可能 MS 無法順利建置，也可能導致在 MS 切換時 新 Slave (原本的 Master) 會收到 新 Master (原本的 Slave) 透過備份檔還原的資料導致重複執行的問題。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>當 &lt;code>gtid_mode = ON&lt;/code> 開啟 GTID 時，雖然不需要生成新的 GTID 但情況特殊需要手動設置 &lt;code>gtid_purged&lt;/code> 時，例如：還原的 Slave 上有多個 channel ……等，這時候就可以設置為 &lt;code>COMMENTED&lt;/code> 後，根據實際需要手動調整該機器的 &lt;code>gtid_purgrd&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="replication-filter">Replication filter
&lt;/h3>&lt;p>曾經線上環境從傳統 Position 點位的 Replication 切換到 GTID 時發生了問題&lt;/p>
&lt;p>Replication 拓樸結構如下：&lt;/p>
&lt;ul>
&lt;li>A Instance 的 test database 同時同步 B, C Instance&lt;/li>
&lt;li>B Instance Replication 給 C，同時設置 Replicat_Do_DB 不包含 test database&lt;/li>
&lt;/ul>
&lt;p>當切換到 GTID 時，會因為以下情況丟失資料：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>A 執行對 test database 的異動 Query 同步給 B, C&lt;/p>
&lt;/li>
&lt;li>
&lt;p>B 收到並執行 A 對 test database 的異動 Query 給 C&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 收到 B 同步過來的 Query，但因為 Replicat_Do_DB 的設置，C 並不會執行 B 同步過來 test database 異動語法。&lt;/p>
&lt;p>&lt;strong>注意： 儘管沒有真的執行，但此時該 GTID 會被加入到 C 的 gtid_executed 中&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>C 隨後收到 A 同步過來的 test database 異動 Query，但因為該 GTID 在步驟 3 已經執行過，所以直接跳過。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>解決方案也很簡單：直接移除 B, C 之間的 replication filter，因為 GTID 不會重複執行不用像傳統 Position 一樣需要 filter 避免重複執行。&lt;/p>
&lt;p>截自官方文檔說明：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Important:&lt;/strong>
For a multi-source replica in a diamond topology (where the replica replicates from two or more sources, which in turn replicate from a common source), when GTID-based replication is in use, ensure that any replication filters or other channel configuration are identical on all channels on the multi-source replica. With GTID-based replication, filters are applied only to the transaction data, and GTIDs are not filtered out. This happens so that a replica’s GTID set stays consistent with the source’s, meaning GTID auto-positioning can be used without re-acquiring filtered out transactions each time. In the case where the downstream replica is multi-source and receives the same transaction from multiple sources in a diamond topology, the downstream replica now has multiple versions of the transaction, and the result depends on which channel applies the transaction first. The second channel to attempt it skips the transaction using GTID auto-skip, because the transaction’s GTID was added to the &lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-options-gtids.html#sysvar_gtid_executed" target="_blank" rel="noopener"
>&lt;code>gtid_executed&lt;/code>&lt;/a> set by the first channel. With identical filtering on the channels, there is no problem because all versions of the transaction contain the same data, so the results are the same. However, with different filtering on the channels, the database can become inconsistent and replication can hang.&lt;/p>&lt;/blockquote>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-rules-channel-based-filters.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 17.2.5.4 Replication Channel Based Filters&lt;/a>&lt;/p></description></item><item><title>MySQL8.0 對於 replication delay 觀測改進</title><link>https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/</link><pubDate>Fri, 23 Dec 2022 12:00:00 +0800</pubDate><guid>https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/</guid><description>&lt;p>在 MySQL 8.0 之前只能從 SHOW SLAVE STATUS 中的 Second_Behind_Master 來確認 replication delay，但是這對於複雜的 replication topologies (拓撲) 不適用，例如：&lt;/p>
&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies.png"
width="541"
height="199"
srcset="https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies_hu_dcadaa07f61f2deb.png 480w, https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies_hu_d274762f2eeb78e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="652px"
>&lt;/p>
&lt;p>如上圖，在 8.0 之前我們在 C 的機器只能知道 B、C 之間的 replication delay，無法知道 A、C 之間的 replication delay，而 MySQL 8.0 進行了一些改善。&lt;/p>
&lt;h2 id="replication-delay-timestamps">&lt;strong>Replication Delay Timestamps&lt;/strong>
&lt;/h2>&lt;p>MySQL 8.0 開始提供了新的方式來測量 replication delay，方法是在 binlog 中為 Transaction 添加以下兩個時間戳：&lt;/p>
&lt;ul>
&lt;li>original_commit_timestamp：紀錄 Transaction 在最原本的 Master commit 的時間戳&lt;/li>
&lt;li>immediate_commit_timestamp：紀錄 Transaction 在 Slave 連線的 Master 上 commit 的時間戳&lt;/li>
&lt;/ul>
&lt;p>透過 mysqlbinlog 指令查看 MySQL 8.0 之後的 binlog：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#221202 18:02:25 server id 1 end_log_pos 707 CRC32 0xf8ff712d Anonymous_GTID last_committed=2 sequence_number=3 rbr_only=yes original_committed_timestamp=1669975345432917 immediate_commit_timestamp=1669975527438008 transaction_length=357
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># original_commit_timestamp=1669975345432917 (2022-12-02 18:02:25.432917 CST)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># immediate_commit_timestamp=1669975527438008 (2022-12-02 18:05:27.438008 CST)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80001 SET @@session.original_commit_timestamp=1669975345432917*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80014 SET @@session.original_server_version=80031*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80014 SET @@session.immediate_server_version=80031*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.GTID_NEXT= &amp;#39;ANONYMOUS&amp;#39;/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># at 707
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>在所有的 Replica 中，所有被回放的 Transaction 其 original_commit_timestamp 始終相同，都是最源頭的 Source 執行該 Query 時 commit 的時間。&lt;/li>
&lt;li>在源頭的 Source binlog 中 original_commit_timestamp 等於 immediate_commit_timestamp。&lt;/li>
&lt;li>在 Replica 的 relay log 中其 original_commit_timestamp 、immediate_commit_timestamp 會等於其連線 Source 上的 binlog 紀錄。&lt;/li>
&lt;li>在 Replica 的 binlog 中，immediate_commit_timestamp 是自己 commit 的時間戳。&lt;/li>
&lt;/ul>
&lt;h2 id="monitoring-replication-delay">&lt;strong>Monitoring Replication Delay&lt;/strong>
&lt;/h2>&lt;p>除了添加了新的 replication delay timestamp，8.0 也在 performance_schema 中新增以下三張表方便觀察 replication delay：&lt;/p>
&lt;ul>
&lt;li>replication_connection_status：紀錄 IO_THREAD 在寫入 relay log 的工作狀態。
&lt;ul>
&lt;li>
&lt;p>LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP&lt;/p>
&lt;p>最後一個已寫入 relay log 的 Transaction 其 original_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_QUEUED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
最後一個已寫入 relay log 的 Transaction 其 immediate_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_QUEUED_TRANSACTION_START_QUEUE_TIMESTAMP
最後一個已寫入 relay log 的 Transaction 的開始時間。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP
最後一個已寫入 relay log 的 Transaction 的結束時間。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>QUEUEING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP
正在寫入 relay log 的 Transaction 其 original_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
正在寫入 relay log 的 Transaction 其 immediate_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP
正在寫入 relay log 的 Transaction 其開始寫入的時間。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>replication_applier_status_by_worker：記錄每一條 SQL_THREAD 的工作狀態。
&lt;ul>
&lt;li>LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP
最後一個被回放的 Transaction 其 original_commit_timestamp。&lt;/li>
&lt;li>LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
最後一個被回放的 Transaction 其 immediate_commit_timestamp。&lt;/li>
&lt;li>LAST_APPLIED_TRANSACTION_START_APPLY_TIMESTAMP
最後一個被回放的 Transaction 其回放的開始時間。&lt;/li>
&lt;li>LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP
最後一個被回放的 Transaction 其回放的結束時間。&lt;/li>
&lt;li>APPLYING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP
正在被回放的 Transaction 其 original_commit_timestamp。&lt;/li>
&lt;li>APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
正在被回放的 Transaction 其 immediate_commit_timestamp。&lt;/li>
&lt;li>APPLYING_TRANSACTION_START_APPLY_TIMESTAMP
正在被回放的 Transaction 其回放的開始時間。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>replication_applier_status_by_coordinator：紀錄 MTS 中的 Coordinator 線程的工作狀態，當未開啟 MTS 此表為空。
&lt;ul>
&lt;li>
&lt;p>LAST_PROCESSED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP
最後一個被 Coordinator 線程處理的 Transaction 其 original_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_PROCESSED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
最後一個被 Coordinator 線程處理的 Transaction 其 immediate_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_PROCESSED_TRANSACTION_START_BUFFER_TIMESTAMP
最後一個 Transaction 什麼時候開始被 Coordinator 寫入 Worker 線程的 buffer。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>LAST_PROCESSED_TRANSACTION_END_BUFFER_TIMESTAMP&lt;/p>
&lt;p>最後一個 Transaction 什麼時候被 Coordinator 寫入 Worker 線程的 buffer。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PROCESSING_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP&lt;/p>
&lt;p>正在被 Coordinator 線程處理的 Transaction 其 original_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP
正在被 Coordinator 線程處理的 Transaction 其 immediate_commit_timestamp。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP&lt;/p>
&lt;p>正在被 Coordinator 線程處理的 Transaction 其開始寫入 Worker 線程的 buffer 的時間。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>注意：這些 Table 中的 immediate_commit_timestamp 都是從 &lt;code>relay log&lt;/code> 中取得。&lt;/p>
&lt;h2 id="範例">範例
&lt;/h2>&lt;p>&lt;img src="https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies.png"
width="541"
height="199"
srcset="https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies_hu_dcadaa07f61f2deb.png 480w, https://FuweaY.github.io/p/mysql-replication-delay-observation-improve/replication-topologies_hu_d274762f2eeb78e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="271"
data-flex-basis="652px"
>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>觀察 A → C 之間完整的延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIMEDIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_APPLIED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_applier_status_by_worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>觀察 B → C 之間完整的延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIMEDIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_APPLIED_TRANSACTION_END_APPLY_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_APPLIED_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_applier_status_by_worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>C 正在回放的 Transaction 和 B 的延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIMEDIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">APPLYING_TRANSACTION_START_APPLY_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">APPLYING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_applier_status_by_worker&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>開啟 MTS 時，Coordinator 正在處理的 Transaction 和 B 的延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIME_DIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSING_TRANSACTION_START_BUFFER_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">PROCESSING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_applier_status_by_coordinator&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>觀察 C relaylog 中最後寫入的 Transaction 在 A commit 的延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIMEDIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_QUEUED_TRANSACTION_END_QUEUE_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">LAST_QUEUED_TRANSACTION_ORIGINAL_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_connection_status&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>觀察 B → C 之間 relaylog 的寫入延遲&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="k">SELECT&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">TIMEDIFF&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">QUEUEING_TRANSACTION_START_QUEUE_TIMESTAMP&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">QUEUEING_TRANSACTION_IMMEDIATE_COMMIT_TIMESTAMP&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">FROM&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">performance_schema&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">replication_connection_status&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="其他用途">其他用途
&lt;/h2>&lt;p>在 binlog 中我們知道有 exec_time 這個值，但這個值並不能讓我們準確的知道 Transaction commit 的確切時間，但在 MySQL 8.0 之後我們可以透過觀測 original_commit_timestamp 來確認，參考以下例子：在一張表上執行了 458752 筆資料的 update，總計花費時間 13.62 sec&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-sql" data-lang="sql">&lt;span class="line">&lt;span class="cl">&lt;span class="n">mysql&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">select&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">update&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">repeat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;c&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">2000&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="c1">---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="c1">---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">2022&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">06&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">08&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">55&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">06&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="c1">---------------------+
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">row&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">00&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="n">Query&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">OK&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">458752&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">affected&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">13&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mi">62&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">sec&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">Rows&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">matched&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">524288&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Changed&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">458752&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>讓我們看一下 binlog：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">#221206 16:55:06 server id 1 end_log_pos 241 CRC32 0x4cc632cf Anonymous_GTID last_committed=0 sequence_number=1 rbr_only=yes original_committed_timestamp=1670316919294397 immediate_commit_timestamp=1670316919294397 transaction_length=190792863
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># original_commit_timestamp=1670316919294397 (2022-12-06 16:55:19.294397 CST)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># immediate_commit_timestamp=1670316919294397 (2022-12-06 16:55:19.294397 CST)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80001 SET @@session.original_commit_timestamp=1670316919294397*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80014 SET @@session.original_server_version=80021*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">/*!80014 SET @@session.immediate_server_version=80021*//*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">SET @@SESSION.GTID_NEXT= &amp;#39;ANONYMOUS&amp;#39;/*!*/;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># at 241
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#221206 16:55:06 server id 1 end_log_pos 325 CRC32 0x3035566a Query thread_id=2244 exec_time=1 error_code=0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#221206 16:55:06 server id 1 end_log_pos 384 CRC32 0xeed08d18 Rows_query
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"># update t1 set name=repeat(&amp;#39;c&amp;#39;,2000)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到 exec_time 顯示的是 1，而不是正確的執行時間，這是因為 exec_time 指的是 update 第一筆資料花費的時間，而不是整個 update 語句執行的時間。&lt;/p>
&lt;p>不過從 MySQL 8.0 開始我們就可以透過 transaction 開始時間 (也就是 16:55:06) 和 transaction commit 的時間 - immediate_commit_timestamp (也就是 16:55:19) 判斷出這個 transaction 執行了 13 sec。&lt;/p>
&lt;h2 id="參考">參考
&lt;/h2>&lt;p>&lt;a class="link" href="https://dev.mysql.com/doc/refman/8.0/en/replication-delayed.html" target="_blank" rel="noopener"
>MySQL :: MySQL 8.0 Reference Manual :: 17.4.11 Delayed Replication&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=7319" target="_blank" rel="noopener"
>MySQL :: WL#7319: Infrastructure for GTID based delayed replication and replication lag monitoring&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://dev.mysql.com/worklog/task/?id=7374" target="_blank" rel="noopener"
>MySQL :: WL#7374: Performance schema tables to monitor replication lags and queue&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://zhuanlan.zhihu.com/p/110874581" target="_blank" rel="noopener"
>新特性解读 | MySQL 8 复制延迟观测新方式，更全面更精准 - 知乎 (zhihu.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/nanxiang/p/13062989.html" target="_blank" rel="noopener"
>binlog记录SQL执行时间吗，准不准，时间是否包含锁等待时间 - 柴米油盐酱醋 - 博客园 (cnblogs.com)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="http://mysql.taobao.org/monthly/2016/03/09/" target="_blank" rel="noopener"
>MySQL · 答疑解惑 · 备库Seconds_Behind_Master计算 (taobao.org)&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://www.cnblogs.com/zhenxing/p/15102590.html" target="_blank" rel="noopener"
>MySQL 复制延迟计算的问题分析 - ZhenXing_Yu - 博客园 (cnblogs.com)&lt;/a>&lt;/p></description></item></channel></rss>