<!doctype html><html lang=zh-tw dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="介紹 MySQL 並行複製"><title>並行複製 (Multi-Thread Slave, MTS)</title>
<link rel=canonical href=https://FuweaY.github.io/p/mysql-mts/><link rel=stylesheet href=/scss/style.min.f28263e5961b456312e0eedc7ff92ffd1c19229bede3556136a281ca9ab8bf59.css><meta property='og:title' content="並行複製 (Multi-Thread Slave, MTS)"><meta property='og:description' content="介紹 MySQL 並行複製"><meta property='og:url' content='https://FuweaY.github.io/p/mysql-mts/'><meta property='og:site_name' content='FuweaY'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Replication'><meta property='article:published_time' content='2025-04-07T12:00:00+08:00'><meta property='article:modified_time' content='2025-04-07T12:00:00+08:00'><meta name=twitter:title content="並行複製 (Multi-Thread Slave, MTS)"><meta name=twitter:description content="介紹 MySQL 並行複製"><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切換選單>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_da86993f15b2a166.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🐱</span></figure><div class=site-meta><h1 class=site-name><a href=/>FuweaY</a></h1><h2 class=site-description>熱愛分享的 DBA 小天地</h2></div></header><ol class=menu-social><li><a href=https://github.com/FuweaY target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>夜晚模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目錄</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#並行複製-multi-thread-slave-mts>並行複製 (Multi-Thread Slave, MTS)</a></li><li><a href=#各個版本的-mts>各個版本的 MTS</a><ol><li><a href=#基於-database-級別的-mts-56>基於 database 級別的 MTS (5.6)</a></li><li><a href=#基於-group-commit-的-mts-57>基於 Group Commit 的 MTS (5.7)</a><ol><li><a href=#group-commit-簡述>Group Commit 簡述</a></li><li><a href=#slave_parallel_type>slave_parallel_type</a></li><li><a href=#logical_clock---commit-parent-based-模式>LOGICAL_CLOCK - Commit Parent Based 模式</a></li><li><a href=#logical_clock----lock-based-模式>LOGICAL_CLOCK - Lock Based 模式</a></li><li><a href=#commit-parent-based-vs-lock-based--舉例>Commit Parent Based VS Lock Based 舉例</a></li><li><a href=#缺陷>缺陷</a></li></ol></li><li><a href=#基於-writeset-的-mts-572280>基於 WriteSet 的 MTS (5.7.22、8.0)</a><ol><li><a href=#writeset-簡述>WriteSet 簡述</a></li><li><a href=#writeset-應用到-mts-簡述>WriteSet 應用到 MTS 簡述</a></li><li><a href=#實現方式>實現方式</a></li></ol></li><li><a href=#writeset-是什麼>WriteSet 是什麼？</a></li><li><a href=#基於-writeset-的-mts-怎麼實現>基於 WriteSet 的 MTS 怎麼實現？</a><ol><li><a href=#binlog_transaction_dependency_tracking-不同對-last_commit-的處理>binlog_transaction_dependency_tracking 不同對 last_commit 的處理</a></li><li><a href=#writeset-歷史紀錄詳解>WriteSet 歷史紀錄詳解</a></li><li><a href=#writeset-mts-對-last_commit-的處理流程>WriteSet MTS 對 last_commit 的處理流程</a></li><li><a href=#writeset_session-怎麼做>WRITESET_SESSION 怎麼做?</a></li><li><a href=#關於-binlog_transaction_dependency_history_size-參數說明>關於 binlog_transaction_dependency_history_size 參數說明</a></li><li><a href=#writeset-不適用情境>WriteSet 不適用情境</a></li></ol></li></ol></li><li><a href=#slave_><strong>slave_preserve_commit_order 介紹</strong></a><ol><li><a href=#gap>GAP</a></li></ol></li><li><a href=#相關參數>相關參數</a></li><li><a href=#官方測試數據>官方測試數據</a></li><li><a href=#親自測試>親自測試</a></li><li><a href=#log>LOG</a></li><li><a href=#懶人包>懶人包</a><ol><li><a href=#mysql-575721-參數設定>MySQL 5.7~5.7.21 參數設定</a></li><li><a href=#mysql-572280xx-參數設定>MySQL 5.7.22~8.0.XX 參數設定</a></li><li><a href=#mts-效率確認>MTS 效率確認</a></li></ol></li><li><a href=#bug>BUG</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/mysql/>MySQL</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/mysql-mts/>並行複製 (Multi-Thread Slave, MTS)</a></h2><h3 class=article-subtitle>介紹 MySQL 並行複製</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Apr 07, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>閱讀時間: 14 分鐘</time></div></footer></div></header><section class=article-content><h2 id=並行複製-multi-thread-slave-mts>並行複製 (Multi-Thread Slave, MTS)</h2><p>在 MySQL 8.0.27 之前，Replica 預設只有一個 IO_THREAD 和一個 SQL_THREAD：</p><ul><li>IO_THREAD 負責從 Source 接收 binlog 並寫入 Replica 的 relaylog</li><li>SQL_THREAD 負責解析和重放 relaylog 中的 event</li></ul><p>當 Source 有併發大量寫入時，Replica 的 IO_THREAD 因為是順序寫入一般不會導致 replication delay，但是只有單線程 SQL_THREAD 回放速度是跟不上有多線程寫入的 Source，因此會造成 replication delay 不斷變大，相應也導致 Replica 的 relaylog 大量堆積占滿 disk 空間。</p><p>因此從 MySQL 5.6 開始提供了 Multi-Tread Slave (MTS)，透過多線程的 SQL_THREAD 來緩解這種問題，並且在後續的大版本中不斷進行優化。</p><h2 id=各個版本的-mts>各個版本的 MTS</h2><h3 id=基於-database-級別的-mts-56>基於 database 級別的 MTS (5.6)</h3><p>在 MySQL 5.6 只有基於 Database 級別的 MTS，只有在不同 Database 的語句才可以並行執行，因此這無法解決單表高寫入所造成的同步延遲。</p><p><img src=/p/mysql-mts/MySQL-56-MTS-ByDatabase.png width=808 height=209 srcset="/p/mysql-mts/MySQL-56-MTS-ByDatabase_hu_76640f19593a5e88.png 480w, /p/mysql-mts/MySQL-56-MTS-ByDatabase_hu_1cab929c3ba48.png 1024w" loading=lazy class=gallery-image data-flex-grow=386 data-flex-basis=927px></p><h3 id=基於-group-commit-的-mts-57>基於 Group Commit 的 MTS (5.7)</h3><h4 id=group-commit-簡述>Group Commit 簡述</h4><p>Group Commit 是 MySQL 5.6 版本引入用來優化 BinLog、RedoLog 在 2PC 時寫入的瓶頸，簡單來說原本每個 Transaction 都需要獨自 <code>fsync</code> 操作來寫入 Disk 持久化，經過 Group Commit 的優化後會將多個 Transaction 組成一個對列一起進行 <code>fsync</code> 操作，大幅減少 <code>fsync</code> 操作解決在雙 1 時造成的性能急速下降的問題。</p><p><img src=/p/mysql-mts/MySQL-5.6-GroupCommit.png width=2000 height=734 srcset="/p/mysql-mts/MySQL-5.6-GroupCommit_hu_68a640d24557e5a3.png 480w, /p/mysql-mts/MySQL-5.6-GroupCommit_hu_a620e3a9d84860da.png 1024w" loading=lazy class=gallery-image data-flex-grow=272 data-flex-basis=653px></p><p>關於 Group Commit 的具體描述，可參考 <a class=link href=https://FuweaY.github.io/p/mysql-group-commit/>MySQL Group Commit 演進</a>。</p><h4 id=slave_parallel_type>slave_parallel_type</h4><p>在 MySQL 5.7 引入了 <code>slave_parallel_type</code> 這個新參數，可使用的值有以下 2 個：</p><ul><li>DATABASE：也就是 5.6 版本，不同 DATABASE 的才能並行回放。</li><li>LOGICAL_CLOCK：5.7 版本基於 Group Commit 的並行回放。</li></ul><h4 id=logical_clock---commit-parent-based-模式>LOGICAL_CLOCK - Commit Parent Based 模式</h4><p>在 Source 中能夠在同一個對列一起進行 Group commit，表示這個對列中的所有 Transaction 都沒有鎖衝突，因此也可在 Replica 內並行回放。</p><p>為了讓 Replica 能基於 Group Commit 實現 MTS，在 Binlog 中為每個 Transaction 添加了 LOGICAL CLOCK 也就是以下 2 個值：</p><ul><li>sequence_number：每個 Transaction 的唯一序列號，具體在 Transaction 進入 flush 階段的對列之前分配。</li><li>last_commited：紀錄上次 Group commit 時最大的 sequence_number，也就是說 last_committed 相同表示同屬一個 Group。</li></ul><p><img src=/p/mysql-mts/binlog-sequence-last-example.png width=2000 height=503 srcset="/p/mysql-mts/binlog-sequence-last-example_hu_6de35104bba7a66b.png 480w, /p/mysql-mts/binlog-sequence-last-example_hu_de30a8103e12b021.png 1024w" loading=lazy alt="透過 mysqlbinlog 可以看到 binlog 中每個 Transaction 都有這 2 個變量" class=gallery-image data-flex-grow=397 data-flex-basis=954px></p><p>透過 mysqlbinlog 可以看到 binlog 中每個 Transaction 都有這 2 個變量</p><p>備註：sequence_number、last_commited 只在同一個 BinLog 文件不重複，每當換到新的 BinLog 文件時會重新從 0 開始計數。</p><hr><p>不過 Commit Parent Based 有一個缺陷，讓我們看一下例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Trx1 ------------P----------C--------------------------------&gt;
</span></span><span class=line><span class=cl>                                |
</span></span><span class=line><span class=cl>Trx2 ----------------P------+---C----------------------------&gt;
</span></span><span class=line><span class=cl>                                |   |
</span></span><span class=line><span class=cl>Trx3 -------------------P---+---+-----C----------------------&gt;
</span></span><span class=line><span class=cl>                                |   |     |
</span></span><span class=line><span class=cl>Trx4 -----------------------+-P-+-----+----C-----------------&gt;
</span></span><span class=line><span class=cl>                                |   |     |    |
</span></span><span class=line><span class=cl>Trx5 -----------------------+---+-P---+----+---C-------------&gt;
</span></span><span class=line><span class=cl>                                |   |     |    |   |
</span></span><span class=line><span class=cl>Trx6 -----------------------+---+---P-+----+---+---C----------&gt;
</span></span></code></pre></td></tr></table></div></div><p>每一個水平線代表一個 Transaction 由左到右的時間點，其中 P 表示 prepare 階段取得上一個 Group 更新 last_committed 的時間點，C 表示 commit 前更新 last_committed 的時間點。</p><p>其中可以觀察到：</p><ul><li>Trx4 的 P 時間點取得的是 Trx1 commit 產生的 last_committed</li><li>Trx5 和 Trx6 的 P 時間點取得的是 Trx2 commit 產生的 last_committed</li></ul><p>依照 Commit Parent 模式下 Trx5、Trx6 可以一起在 Replica 回放，但是 Trx4 不可以和 Trx5、Trx6 一起在 Replica 回放。</p><p>然而，實際上依照時間線我們可以看到 Trx4 在 prepare 到 commit 的過程中，Trx5、Trx6 有在這個過程中 prepare，也就是說實際上他們並沒有鎖衝突 (如果衝突 Trx5、Trx6 會卡在 lock wait)，所以理論上他們在 Replica 是可以並行回放到。</p><h4 id=logical_clock----lock-based-模式>LOGICAL_CLOCK - Lock Based 模式</h4><p>為了進一步優化 Commit Parent Based 的缺陷，MySQL 5.7 馬上實現了 <a class=link href="https://dev.mysql.com/worklog/task/?id=7165" target=_blank rel=noopener>MySQL :: WL#7165: MTS: Optimizing MTS scheduling by increasing the parallelization window on master</a> 的優化，也就是基於 Lock Based 模式的 LOGICAL_CLOCK，只要 Transaction 在各自持有的鎖沒有衝突時就可以並行執行。</p><p>在此模式下 binlog 中的 sequence_number、last_commited 涵義如下：</p><ul><li>sequence_number：每個 Transaction 的唯一序列號，具體在 Transaction 進入 flush 階段的對列之前分配，</li><li>last_commited：當 Transaction 開始加鎖時，將全局變量 max_committed_transaction 當下的值作為 last_commited。<ul><li>全局變量 max_committed_transaction：已經結束 Lock interval 的最大 sequence_number，每個 Transaction 在 InnoDB commit 階段時，如果自己的 sequence_number > max_committed_transaction 時會將其更新為自己的 sequence_number 。</li><li>因為無法預先知道哪一個鎖是最後一個，因此 Transaction 內每一個 DML 都會不斷更新該 Transaction 的 last_commited。</li></ul></li></ul><p>在 Source 寫入 sequence_number、last_commited 之後，接下來就是看 Replica 如何依據這 2 個直來實現 Lock Based 的 MTS。</p><p>首先複習一下，只有當 Transaction 和 Transaction 在 Lock ~ Commit (也就是釋放鎖) 之間有交集才能在 Replica 並行回放：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>- Can execute in parallel:
</span></span><span class=line><span class=cl>    Trx1 -----L---------C------------&gt;
</span></span><span class=line><span class=cl>    Trx2 ----------L---------C-------&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- Can not execute in parallel:
</span></span><span class=line><span class=cl>    Trx1 -----L----C-----------------&gt;
</span></span><span class=line><span class=cl>    Trx2 ---------------L----C-------&gt;
</span></span></code></pre></td></tr></table></div></div><p>讓我們首先為上圖中的 L~C 的期間定義一個新的名詞 <code>Lock interval</code>：</p><ul><li>Lock interval 的起始點(上圖L)：在 Binlog Prepare 階段取得最後一把鎖的時間點。</li><li>Lock interval 的結束點(上圖C)：在 InnoDB Commit 階段釋放第一把鎖的時間點。</li></ul><p>也就是說對於 Replica 在讀取 BinLog 時：</p><ul><li>last_commited 作為 Lock interval 的起始點：因為 Transaction 開始加鎖的邏輯時間是目前最後一個已結束 lock interval 的最後一個 sequence_number，就是全局變量 max_committed_transaction。</li><li>sequence_number 作為 Lock interval 的結束點：因為當該 Transaction 結束 lock interval 時會將自己的 sequence_number 更新到 max_committed_transaction，也就是說對於下個 Transaction 而言的 last_commited。</li></ul><p>在 Replica 回放時只有 Transaction 之間如果 last_commited~sequence_number 之間有重疊就可以並行回放。</p><p>實現方式如下：</p><ul><li>定義一個變量 <code>last_lwm_timestamp</code>：為一個已經完成回放 Transaction 的 sequence_number ，該 Transaction 其 sequence_number 之前的所有 Transaction 都已經 commit。</li><li>當 coordinator 線程讀取一個 Transaction 的 last_committed：<ul><li><p>當 <code>last_committed</code> &lt; <code>last_lwm_timestamp</code> 表示 Lock interval 有交集，因此可以丟給 work 線程並行回放。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    Trx1 -----L---------C------------&gt;
</span></span><span class=line><span class=cl>    Trx2 ----------L---------C-------&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p>當 <code>last_committed</code> = <code>last_lwm_timestamp</code> 雖然 Lock interval 沒有交集，但是該情況表示前一個 Transaction 完成，所以當前 Transaction 才會拿到前一個的 sequence_number 作為自己的 last_commited，而 <code>last_lwm_timestamp</code> 是已經 commit 的 Transaction，因此可以丟給 work 線程回放了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    Trx1 -----L----C-----------------&gt;
</span></span><span class=line><span class=cl>    Trx2 ----------L---------C-------&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p>當 <code>last_committed</code> > <code>last_lwm_timestamp</code> 表示 Lock interval 沒有交集，因此不能丟給 work 線程並行回放。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>    Trx1 -----L----C-----------------&gt;
</span></span><span class=line><span class=cl>    Trx2 ---------------L----C-------&gt;
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><h4 id=commit-parent-based-vs-lock-based--舉例>Commit Parent Based VS Lock Based 舉例</h4><p>假設有以下 binlog：</p><p><img src=/p/mysql-mts/Commit-vs-Lock-Binlog-example.png width=755 height=282 srcset="/p/mysql-mts/Commit-vs-Lock-Binlog-example_hu_f5f40e55cf9bafe5.png 480w, /p/mysql-mts/Commit-vs-Lock-Binlog-example_hu_3613004070a757c1.png 1024w" loading=lazy class=gallery-image data-flex-grow=267 data-flex-basis=642px></p><p>在 Commit Parent Based 下：</p><ul><li>sequence_number 1~7 的 Transaction 其 last_committed 都是 0，所以可在 replica 並行回放。</li><li>sequence_number 8 的 Transaction 其 last_committed 是 1，所以不能和 sequence_number 1~7一起在 replica 並行回放。
*備註：在 Commit Parent Based 下，正確的 last_committed 應該要是 7，此處僅方便舉例使用 Lock Based 舉例。</li><li>sequence_number 9<del>14 的 Transaction 其 last_committed 都是 7，不能和 sequence_number 1</del>8 一起在 replica 並行回放。</li></ul><p>在 Lock Based 下：</p><ul><li>sequence_number 1<del>7 的 Transaction 其 last_committed 都是 0 表示為同一個 Group，所以 1</del>7 可在 replica 並行回放。</li><li>sequence_number 8 的 last_committed = 1，表示 8 和 1<del>7 的鎖不衝突，因此 1</del>8 可在 replica 並行回放。</li><li>sequence_number 9<del>14 的 Transaction 其 last_committed 都是 7 表示為同一個 Group，同時 8</del>14 的鎖不衝突，因次 8~14 可在 replica 並行回放</li></ul><h4 id=缺陷>缺陷</h4><p>基於 Group Commit 的 MTS 不論是 Commit Parent Based 還是 Lock Based 都一樣，都是只有在 Source 上每個 Group 的 Transaction 足夠多，也就是併發度夠高的情況下才能在 Replica 上有較好的並行回放效率。</p><p>雖然在 5.7 新增 <code>binlog_group_commit_sync_delay</code>、<code>binlog_group_commit_sync_no_delay_count</code>這 2 個設定，可以讓一個 Group 有更多的 Transaction，然而效果仍然十分有限。</p><h3 id=基於-writeset-的-mts-572280>基於 WriteSet 的 MTS (5.7.22、8.0)</h3><p>MySQL 5.7 雖然透過 Group Commit 優化了 MTS，但這主要是優化在 Master 上有高並行度的情況下，如果 Master 並行度不高則同一個 Group 的 Event 相對少，因此 Slave 回放速度無法有效加快。</p><p>在 8.0 為了解決上述問題，即使在 Source 上是串行 commit 的 Transaction，只要互相不衝突那麼在 Replica 上就能並行回放。</p><p>在 8.0 新增了 <code>binlog_transaction_dependency_tracking</code> 這個參數來控制 binlog 寫入相關資訊，讓 Replica 據此進行並行回放，有以下三個值：</p><ul><li>COMMIT_ORDER：使用 5.7 Group commit 的方式判斷。</li><li>WRITESET：使用 WriteSet 的方式判斷 Transaction 是否有衝突。</li><li>WRITESET_SESSION：WRITESET 的基礎上保證同一個 session 內的 Transaction 不可並行。</li></ul><h4 id=writeset-簡述>WriteSet 簡述</h4><p><code>WriteSet</code> 在 MySQL Group Replication(MGR) 中就已經實現了：</p><p><img src=/p/mysql-mts/MySQL-Group-Replication-Protocol.png width=725 height=328 srcset="/p/mysql-mts/MySQL-Group-Replication-Protocol_hu_e322ba252aa71e47.png 480w, /p/mysql-mts/MySQL-Group-Replication-Protocol_hu_21b180ab73ce6bc5.png 1024w" loading=lazy alt="MySQL Group Replication Protocol" class=gallery-image data-flex-grow=221 data-flex-basis=530px></p><p><strong>MySQL Group Replication Protocol</strong></p><p>使用的地方是 certify 階段用來判斷 Transaction 是否允許 commit，這個時候就會透過 <code>WriteSet</code> 來判斷是否和其他 member 上的 Transaction 有衝突。</p><blockquote><p>💡 因為 MGR 可以在多個 member 上寫入，因此不像單機模式可以透過 Lock 衝突來避免 Transaction 之間的衝突，同時為了提高效能 MGR 採用樂觀的方式不透過其他方式額外加鎖，只有準備 commit 的時候透過 <code>WriteSet</code> 判斷 member 之間的 Transaction 是否衝突。</p></blockquote><h4 id=writeset-應用到-mts-簡述>WriteSet 應用到 MTS 簡述</h4><p>假設在 Source 上 Transaction commit 時間軸如下，同一個時間只有 1~2 個 Transaction：</p><p><img src=/p/mysql-mts/WriteSet-Master-Exe.png width=648 height=380 srcset="/p/mysql-mts/WriteSet-Master-Exe_hu_4b68f14e9e9e9c30.png 480w, /p/mysql-mts/WriteSet-Master-Exe_hu_d08660c747a2776c.png 1024w" loading=lazy alt="Source 執行狀況" class=gallery-image data-flex-grow=170 data-flex-basis=409px></p><p>上途中方塊對應 Transaction 修改的資料範圍，如果沒有重疊表示 Transaction 之間修改的數據不衝突，那麼透過 WriteSet 判斷 Transaction 之間是否衝突後，就可以在 Replica上如下並行：</p><p><img src=/p/mysql-mts/WriteSet-MTS.png width=632 height=370 srcset="/p/mysql-mts/WriteSet-MTS_hu_86231a346efed00b.png 480w, /p/mysql-mts/WriteSet-MTS_hu_be99f3b638c3b1d0.png 1024w" loading=lazy alt="基於 WriteSet 的 MTS 回放狀況" class=gallery-image data-flex-grow=170 data-flex-basis=409px></p><p>不過上圖有個小問題是可能發生 T3 比 T2 早執行的狀況，導致 Source 和 Replica 中同一個 session 產生有不同的執行紀錄，如果評估後覺得不可接受有以下 2 個方式可以解決：</p><ul><li>slave_preserve_commit_order = ON</li><li>binlog_transaction_dependency_tracking = WRITESET_SESSION</li></ul><p><img src=/p/mysql-mts/slave-preserve-commit-order-on.png width=643 height=385 srcset="/p/mysql-mts/slave-preserve-commit-order-on_hu_e87cd167b19860.png 480w, /p/mysql-mts/slave-preserve-commit-order-on_hu_24a9cbd16fb7acf6.png 1024w" loading=lazy alt="基於 WRITESET_SESSION 或 slave_preserve_commit_order = ON 設定後 MTS 回放狀況" class=gallery-image data-flex-grow=167 data-flex-basis=400px></p><p>如上圖調整後可以發現同一個 session 的都不能並行回放。</p><h4 id=實現方式>實現方式</h4><h3 id=writeset-是什麼>WriteSet 是什麼？</h3><p>WriteSet 是一個 hash 數組，大小由 <code>binlog_transaction_dependency_history_size</code> 來決定。</p><p>在 InooDB 修改數據後，會將修改的 row 數據以下內容進行 hash 後寫入 <code>WriteSet</code>：</p><p><img src=/p/mysql-mts/WriteSet-internal-Structure.png width=1080 height=61 srcset="/p/mysql-mts/WriteSet-internal-Structure_hu_4e3a3c9ac483c1d2.png 480w, /p/mysql-mts/WriteSet-internal-Structure_hu_d2aceffb4048a3f4.png 1024w" loading=lazy alt="WriteSet 結構" class=gallery-image data-flex-grow=1770 data-flex-basis=4249px></p><ul><li><p>WriteSet 產出細節</p><blockquote><p>💡 產生的 Hash 值的方式可以參考 sql/rpl_write_set_handler.cc 中的 add_pke function
<a class=link href=https://github.com/mysql/mysql-server/blob/8.0/sql/rpl_write_set_handler.cc target=_blank rel=noopener>mysql-server/rpl_write_set_handler.cc at 8.0 · mysql/mysql-server · GitHub</a></p></blockquote><p>範例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=n>use</span><span class=w> </span><span class=n>db_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Database</span><span class=w> </span><span class=n>changed</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>show</span><span class=w> </span><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=err>\</span><span class=k>G</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>***************************</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=k>row</span><span class=w> </span><span class=o>***************************</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>Table</span><span class=p>:</span><span class=w> </span><span class=k>table_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>Create</span><span class=w> </span><span class=k>Table</span><span class=p>:</span><span class=w> </span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>pk_column</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>uk_column</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>idx_column</span><span class=o>`</span><span class=w> </span><span class=nb>int</span><span class=p>(</span><span class=mi>11</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>pk_column</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>uk_column</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>uk_column</span><span class=o>`</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>idx_column</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>idx_column</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>InnoDB</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8mb4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>db_name</span><span class=p>.</span><span class=k>table_name</span><span class=w> </span><span class=k>VALUES</span><span class=p>(</span><span class=mi>6</span><span class=p>,</span><span class=w> </span><span class=mi>7</span><span class=p>,</span><span class=w> </span><span class=mi>8</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 透過編譯 mysqld debug 執行查看</span>
</span></span><span class=line><span class=cl>~ -&gt; tail -f /tmp/mysqld.trace
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &lt;generate_hash_pke <span class=m>441</span>
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &gt;generate_hash_pke
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &gt;Rpl_transaction_write_set_ctx::add_write_set
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &lt;Rpl_transaction_write_set_ctx::add_write_set <span class=m>51</span>
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> info: pke: PRIMARY½db_name½7table_name½106½1<span class=p>;</span> hash: <span class=m>10113078337023140702</span>
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &lt;generate_hash_pke <span class=m>441</span>
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &gt;generate_hash_pke
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &gt;Rpl_transaction_write_set_ctx::add_write_set
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> &lt;Rpl_transaction_write_set_ctx::add_write_set <span class=m>51</span>
</span></span><span class=line><span class=cl>T@6: <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> <span class=p>|</span> info: pke: uk_column½db_name½7table_name½107½1<span class=p>;</span> hash: <span class=m>406567197175550244</span>
</span></span></code></pre></td></tr></table></div></div><p>偽代碼如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=err>如果表中存在索引：</span>
</span></span><span class=line><span class=cl>   <span class=err>将数据库名，表名信息写入临时变量</span>
</span></span><span class=line><span class=cl>   <span class=err>循环扫描表中每个索引：</span>
</span></span><span class=line><span class=cl>        <span class=err>如果不是唯一索引：</span>
</span></span><span class=line><span class=cl>             <span class=err>退出本次循环继续循环。</span>
</span></span><span class=line><span class=cl>        <span class=err>循环两种生成数据的方式</span><span class=p>(</span><span class=err>二进制格式和字符串格式</span><span class=p>)</span><span class=err>：</span>
</span></span><span class=line><span class=cl>             <span class=err>将索引名字写入到</span><span class=n>pke中</span><span class=err>。</span>
</span></span><span class=line><span class=cl>             <span class=err>将临时变量信息写入到</span><span class=n>pke中</span><span class=err>。</span>
</span></span><span class=line><span class=cl>             <span class=err>循环扫描索引中的每一个字段：</span>
</span></span><span class=line><span class=cl>                <span class=err>将每一个字段的信息写入到</span><span class=n>pke中</span><span class=err>。</span>
</span></span><span class=line><span class=cl>                <span class=err>如果字段扫描完成：</span>
</span></span><span class=line><span class=cl>                   <span class=err>将</span><span class=n>pke生成hash值并且写入到写集合中</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    <span class=err>如果没有找到主键或者唯一键记录一个标记，后面通过这个标记来</span>
</span></span><span class=line><span class=cl>    <span class=err>判定是否使用</span><span class=n>Writeset的并行复制方式</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=基於-writeset-的-mts-怎麼實現>基於 WriteSet 的 MTS 怎麼實現？</h3><p>該模式下 Replica 同樣是基於 Source 產生的 binlog 中的 <code>last_commited</code> 和 <code>sequenct_number</code> 來決定是否可以並行回放，也就是說如果要進一步增加並行回放的效率，就需要盡可能為每個 Transaction 找出更小的 <code>last_commited</code>。</p><p>基於 WriteSet 的 MTS 能找出更小的 <code>last_commited</code> 的方式就是維護一個先前 Transaction 所組成的 WriteSet 的歷史紀錄，之後新進來的 Transaction 計算 WriteSet 後和這個歷史紀錄進行衝突比對，以此來嘗試找出更小的 <code>last_commited</code>。</p><h4 id=binlog_transaction_dependency_tracking-不同對-last_commit-的處理>binlog_transaction_dependency_tracking 不同對 last_commit 的處理</h4><p>基於 WriteSet 的 MTS 實際上是基於 ORDER_COMMIT (Group Commit) 進一步處理而已。</p><p>根據 binlog_transaction_dependency_tracking 的設定不同，在 Source code 有如下內容：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>case</span> <span class=nl>DEPENDENCY_TRACKING_COMMIT_ORDER</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>m_commit_order</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>DEPENDENCY_TRACKING_WRITESET</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>m_commit_order</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>m_writeset</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nl>DEPENDENCY_TRACKING_WRITESET_SESSION</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>m_commit_order</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>m_writeset</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=n>m_writeset_session</span><span class=p>.</span><span class=n>get_dependency</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到從 COMMIT_ORDER 到 WRITESET 再到 WRITESET_SESSION 其實都是以上一個設定的為基礎進一步透過一個新的 function 進行修改而已，這些 function 修改的是 <code>last_commited</code> 值。</p><h4 id=writeset-歷史紀錄詳解>WriteSet 歷史紀錄詳解</h4><p>WriteSet 的歷史紀錄包含了 2 個元素：</p><ul><li>WriteSet 的 Hash 值</li><li>最後一次修改該行的 Transaction 其 <code>sequence_number</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    Track the last transaction sequence number that changed each row
</span></span></span><span class=line><span class=cl><span class=cm>    in the database, using row hashes from the writeset as the index.
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl>  <span class=k>typedef</span> <span class=n>std</span><span class=o>::</span><span class=n>map</span><span class=o>&lt;</span><span class=n>uint64</span><span class=p>,</span><span class=n>int64</span><span class=o>&gt;</span> <span class=n>Writeset_history</span><span class=p>;</span> <span class=c1>//map实现
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Writeset_history</span> <span class=n>m_writeset_history</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>另外 <code>binlog_transaction_dependency_history_size</code> 決定了可以儲存幾組紀錄，內部會依照 WriteSet Hash 值進行排序。</p><p>如果 WriteSet 的歷史紀錄達到 <code>binlog_transaction_dependency_history_size</code> 設定的值就會將歷史紀錄清空，並且本次的 Transaction 會成為清空後歷史紀錄的第一筆紀錄。</p><p>另外除了歷史紀錄還有有一個 <code>m_writeset_history_start</code> 的值，用來儲存這個歷史紀錄中的最小 <code>sequence_number</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>exceeds_capacity</span> <span class=o>||</span> <span class=o>!</span><span class=n>can_use_writesets</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//Writeset的历史MAP已满
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_writeset_history_start</span><span class=o>=</span> <span class=n>sequence_number</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>//如果超过最大设置，清空writeset history。从当前seq number 重新记录， 也就是最小的那个事务seq number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>//清空历史MAP
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=writeset-mts-對-last_commit-的處理流程>WriteSet MTS 對 last_commit 的處理流程</h4><p>這裡透過一個例子解釋，假設如下：</p><ul><li>當前的 Transaction 基於 ORDER_COMMIT (Group Commit) 的方式產生了結果：<ul><li>last_commit = 125</li><li>sequence_number = 130</li></ul></li><li>該 Transaction 修改的表只有 PK 沒有 UK。</li><li>該 Transaction 修改了 4 行資料，分別為 ROW1、ROW7、ROW6、ROW10。</li></ul><p>下圖展示了該 Transaction 和 WriteSet 歷史紀錄：</p><p><img src=/p/mysql-mts/WriteSet-search-lastCommit.png width=1120 height=1069 srcset="/p/mysql-mts/WriteSet-search-lastCommit_hu_615814ac450fa60f.png 480w, /p/mysql-mts/WriteSet-search-lastCommit_hu_d78a2671fa2b38d4.png 1024w" loading=lazy class=gallery-image data-flex-grow=104 data-flex-basis=251px></p><p>接下來就會透過 WriteSet 方式找到更小的 last_commit：</p><ol><li><p>將 last_commit 由 125 調整為 100 (歷史紀錄中最小的 sequence_number <code>m_writeset_history_start</code>)。</p><p>備註：因為該 Transaction 比歷史紀錄中的 Transaction 晚執行，因此 last_commit 一定都比他們的 sequence_number 大。</p></li><li><p>將 ROW1 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：</p><ul><li>將歷史紀錄中該行的 sequence_number 由 120 (歷史紀錄值) 調整為 130(該 Transaction)。</li><li>將該 Transaction 的 last_commit 由 100 調整為 120。</li></ul></li><li><p>將 ROW7 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：</p><ul><li>將歷史紀錄中該行的 sequence_number 由 114 (歷史紀錄值) 調整為 130(該 Transaction)。</li><li>當前 Transaction 當前 last_commit 為 120 比歷史紀錄中的 114 大，因為在 120 就衝突了，所以不能改成更小的 114，因此 last_commit 不變依舊是 120。</li></ul></li><li><p>將 ROW6 的 Hash 值在 WriteSet 歷史紀錄中確認，發現有修改相同紀錄的 Transaction：</p><ul><li>將歷史紀錄中該行的 sequence_number 由 105 (歷史紀錄值) 調整為 130(該 Transaction)。</li><li>當前 Transaction 當前 last_commit 為 120 比歷史紀錄中的 105 大，因為在 120 就衝突了，所以不能改成更小的 105，因此 last_commit 不變依舊是 120。</li></ul></li><li><p>將 ROW10 的 Hash 值在 WriteSet 歷史紀錄中確認，發現並沒有修改相同紀錄的 Transaction：</p><ul><li>因為沒有找到相同的 WriteSet，因此需要把該 Transaction ROW10 的 Hast 值和 sequence_number 寫入 WriteSet 歷史紀錄。<ul><li>如果歷史紀錄大小超過 <code>binlog_transaction_dependency_history_size</code>，則清空當前歷史紀錄，隨後將 Transaction ROW10 的 Hast 值和 sequence_number(130) 寫入 WriteSet 新的歷史紀錄，並將 <code>m_writeset_history_start</code> 改為 130。</li><li>如果歷史紀錄大小沒有超過 <code>binlog_transaction_dependency_history_size</code>，將 Transaction ROW10 的 Hast 值和 sequence_number(130) 寫入 WriteSet 當前歷史紀錄。</li></ul></li></ul></li></ol><p>整個過程結束，該 Transaction 的 last_commit 由原本的 125 降低為 120，最後結果如下圖：</p><p><img src=/p/mysql-mts/WriteSet-Change-lastCommit.png width=1117 height=1104 srcset="/p/mysql-mts/WriteSet-Change-lastCommit_hu_5ae3d1b1f4d24fcd.png 480w, /p/mysql-mts/WriteSet-Change-lastCommit_hu_35d7a891f6ed0d5f.png 1024w" loading=lazy class=gallery-image data-flex-grow=101 data-flex-basis=242px></p><ul><li><p>該過程在 Function <code>Writeset_trx_dependency_tracker::get_dependency</code> 中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>can_use_writesets</span><span class=p>)</span> <span class=c1>//如果能够使用writeset 方式
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     Check if adding this transaction exceeds the capacity of the writeset
</span></span></span><span class=line><span class=cl><span class=cm>     history. If that happens, m_writeset_history will be cleared only after  而 add_pke
</span></span></span><span class=line><span class=cl><span class=cm>     using its information for current transaction.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>exceeds_capacity</span><span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=n>writeset</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>()</span> <span class=o>&gt;</span> <span class=n>m_opt_max_history_size</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>//如果大于参数binlog_transaction_dependency_history_size设置清理标记
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     Compute the greatest sequence_number among all conflicts and add the
</span></span></span><span class=line><span class=cl><span class=cm>     transaction&#39;s row hashes to the history.
</span></span></span><span class=line><span class=cl><span class=cm>    */</span>
</span></span><span class=line><span class=cl>    <span class=n>int64</span> <span class=n>last_parent</span><span class=o>=</span> <span class=n>m_writeset_history_start</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//临时变量，首先设置为最小的一个seq number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>uint64</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span><span class=o>=</span> <span class=n>writeset</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>writeset</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//循环每一个Writeset中的每一个元素 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Writeset_history</span><span class=o>::</span><span class=n>iterator</span> <span class=n>hst</span><span class=o>=</span> <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//是否在writeset history中 已经存在了。 map中的元素是 key是writeset 值是sequence number
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>hst</span> <span class=o>!=</span> <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=c1>//如果存在
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>{</span>    
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>hst</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&gt;</span> <span class=n>last_parent</span> <span class=o>&amp;&amp;</span> <span class=n>hst</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;</span> <span class=n>sequence_number</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>          <span class=n>last_parent</span><span class=o>=</span> <span class=n>hst</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>//如果已经大于了不需要设置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>hst</span><span class=o>-&gt;</span><span class=n>second</span><span class=o>=</span> <span class=n>sequence_number</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>//更改这行记录的sequence_number
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>exceeds_capacity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>uint64</span><span class=p>,</span> <span class=n>int64</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>,</span> <span class=n>sequence_number</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>//没有冲突则插入。
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>......</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>write_set_ctx</span><span class=o>-&gt;</span><span class=n>get_has_missing_keys</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1>//如果没有主键和唯一键那么不更改last commit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>       The WRITESET commit_parent then becomes the minimum of largest parent
</span></span></span><span class=line><span class=cl><span class=cm>       found using the hashes of the row touched by the transaction and the
</span></span></span><span class=line><span class=cl><span class=cm>       commit parent calculated with COMMIT_ORDER.
</span></span></span><span class=line><span class=cl><span class=cm>      */</span><span class=err>；</span>
</span></span><span class=line><span class=cl>      <span class=n>commit_parent</span><span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>last_parent</span><span class=p>,</span> <span class=n>commit_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//这里对last commit做更改了。降低他的last commit
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>exceeds_capacity</span> <span class=o>||</span> <span class=o>!</span><span class=n>can_use_writesets</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_writeset_history_start</span><span class=o>=</span> <span class=n>sequence_number</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=c1>//如果超过最大设置 清空writeset history。从当前sequence 重新记录 也就是最小的那个事务seqnuce number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>m_writeset_history</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span><span class=c1>//清空真个MAP
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=writeset_session-怎麼做>WRITESET_SESSION 怎麼做?</h4><p>前面有提到過 WRITESET_SESSION 是基於 WRITESET 的基礎上繼續處理的，WRITESET_SESSION 要做到的是同一個 session 的 Transaction 不能在 Replica 並行回放，要實現非常簡單：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>int64</span> <span class=n>session_parent</span><span class=o>=</span> <span class=n>thd</span><span class=o>-&gt;</span><span class=n>rpl_thd_ctx</span><span class=p>.</span><span class=n>dependency_tracker_ctx</span><span class=p>().</span>
</span></span><span class=line><span class=cl>                        <span class=n>get_last_session_sequence_number</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>//取本session的上一次事务的seq number
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>session_parent</span> <span class=o>!=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>session_parent</span> <span class=o>&lt;</span> <span class=n>sequence_number</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=c1>//如果本session已经做过事务并且本次当前的seq number大于上一次的seq number
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>commit_parent</span><span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>commit_parent</span><span class=p>,</span> <span class=n>session_parent</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//说明这个session做过多次事务不允许并发，修改为order_commit生成的last commit
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>thd</span><span class=o>-&gt;</span><span class=n>rpl_thd_ctx</span><span class=p>.</span><span class=n>dependency_tracker_ctx</span><span class=p>().</span>
</span></span><span class=line><span class=cl>    <span class=n>set_last_session_sequence_number</span><span class=p>(</span><span class=n>sequence_number</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>//设置session_parent的值为本次seq number的值
</span></span></span></code></pre></td></tr></table></div></div><h4 id=關於-binlog_transaction_dependency_history_size-參數說明>關於 binlog_transaction_dependency_history_size 參數說明</h4><p>該參數默認值為 25000，代表的是 WriteSet 裡元素的數量。</p><p>從前面 WriteSet 實現細節說明中我們可以知道修改一行數據可能會產生多個 Hash，所以這個值不會等於修改的行數，可以理解為如下：</p><ul><li>5.7 版本：binlog_transaction_dependency_history_size = 修改的行數 * ( 1 + UK 數量 ) * 2</li><li>8.0 版本：binlog_transaction_dependency_history_size = 修改的行數 * ( 1 + UK 數量 )</li></ul><p>備註：不同原因在於 5.7 會生成包含 collation 和不包含 collation，在 8.0 中則沒有。</p><p>如果將這個參數加大，那麼 Source 上的 WriteSet 就能放越多的元素，也就是說 Transaction 可以生成更小的 last_commited，這在 Replica 上就能提高並行回放的效率，當然缺點就是在 Source 會消耗更多的資源。</p><h4 id=writeset-不適用情境>WriteSet 不適用情境</h4><p>以下情境不適用 WriteSet，MySQL 會自動退回使用 commit_order (基於 group commit) 模式</p><ol><li>沒有 PK 也沒有 UK</li><li>DDL</li><li>session 的 hash 算法換 history 不同</li><li>Transaction 更新了有 Forign key 關聯的欄位</li></ol><h2 id=slave_><strong>slave_preserve_commit_order 介紹</strong></h2><p>當開啟 MTS 且 slave_parallel_type = LOGICAL_CLOCK (不論具體是基於 commit_order 還是 writeset) 的時候，有可能會發生 Source 和 Replica 執行順序不同的情況，雖然這並不會導致資料不一致的狀況，但是可能會發生在 Source 上先看到 T1 才看到 T2 卻在 Replica 上卻是先看到 T2 才看到 T1 執行，也就是說在 Source 和 Replica 各自的 binlog 歷史紀錄順序也會不一致，沒有保證 <code>Causal Consistency</code>。</p><blockquote><p>💡 <code>Causal Consistency</code> (因果一致性) 意思是如果兩個事件有因果關係，那麼在所有節點都必須能觀測到這種因果關係。</p></blockquote><p>如果評估業務需要保證<code>Causal Consistency</code>，除了不使用 MTS 使用單線程 replication 也可以透過設置 <code>slave_preserve_commit_order=ON</code> 來避免，這會讓 Replica 上回放的 Transaction 在進入 flush 階段之前會先等待 sequence_number 之前的 Transaction 先進入 flush 階段。</p><h3 id=gap>GAP</h3><p>如果 <code>slave_preserve_commit_order = OFF</code> 除了上面提到 <code>Causal Consistency</code> 還有一個問題在官方文檔中稱為 GAP。</p><p>開啟 MTS 時透過 show slave status 查看 <code>Exec_Source_Log_Pos</code> 指的是 <code>low-watermark</code> 也就是保證這個 postition 之前的 Transaction 都已經 commit，但是該 postition 之後的 Transaction 有可能 commit 也可能沒有 commit，</p><h2 id=相關參數>相關參數</h2><ul><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_parallel_workers target=_blank rel=noopener>slave_parallel_workers</a> (5.6 ~ 8.0.25)、<a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_parallel_workers target=_blank rel=noopener>replica_parallel_workers</a> (8.0.26 ~)</p><p><img src=/p/mysql-mts/slave-parallel-workers.png width=575 height=343 srcset="/p/mysql-mts/slave-parallel-workers_hu_4d041eb8e44d22f6.png 480w, /p/mysql-mts/slave-parallel-workers_hu_ec466e839f6fe4b6.png 1024w" loading=lazy class=gallery-image data-flex-grow=167 data-flex-basis=402px></p><p>設定要在 replica 並行的 thread 數量。</p><p>如果 slave 有多個 channel，則每個 channel 都會有此數量的 thread。</p><p>設置此參數後必須重新 START REPLICA 才會生效。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_parallel_type target=_blank rel=noopener>slave_parallel_type</a> (5.7 ~ 8.0.25)、<a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_parallel_type target=_blank rel=noopener>replica_parallel_type</a> (8.0.26 ~ 8.0.29)</p><p><img src=/p/mysql-mts/replica-parallel-type.png width=574 height=366 srcset="/p/mysql-mts/replica-parallel-type_hu_3bead051496654f6.png 480w, /p/mysql-mts/replica-parallel-type_hu_1946b811ede79cec.png 1024w" loading=lazy class=gallery-image data-flex-grow=156 data-flex-basis=376px></p><p>設定在 replica 上允許哪些 Transaction 並行回放</p><ul><li>DATABASE：Transaction 必須作用於不同 Database 才能並行。</li><li>LOGICAL_CLOCK：基於 Source 寫入 binlog 的 timestamp 來決定 Transaction 的並行，也就是基於 Group Commit。</li></ul><p>建議將 binlog_transaction_dependency_tracking 設置為 WRITESET 或 WRITESET_SESSION ，這樣在合適的情況下會走 WriteSet 來提高並行度。</p><p>預計 8.0.29 之後棄用此參數，總是以 LOGICAL_CLOCK 的方式運行。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_group_commit_sync_delay target=_blank rel=noopener>binlog_group_commit_sync_delay</a></p><p><img src=/p/mysql-mts/binlog-group-commit-sync-delay.png width=575 height=313 srcset="/p/mysql-mts/binlog-group-commit-sync-delay_hu_ef403cd4f4b0234.png 480w, /p/mysql-mts/binlog-group-commit-sync-delay_hu_d0b4236f64d57c5d.png 1024w" loading=lazy class=gallery-image data-flex-grow=183 data-flex-basis=440px></p><p>控制 binlog commit 之後等待 N 微秒後才 fsync 到 Disk，設置越大單個 Group 可以有更多時間等到更多的 Transaction 一起 fsync Disk，減少 fsync 的次數及減少每個 Transaction commit 的單位時間。</p><p>此外適度的增加對於以下設置的 MTS 也能增加在 Slave 的並行度：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># Master
</span></span><span class=line><span class=cl>binlog_transaction_dependency_tracking = COMMIT_ORDER
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Slave
</span></span><span class=line><span class=cl>slave_parallel_type = LOGICAL_CLOCK
</span></span></code></pre></td></tr></table></div></div><p>注意：會增加 server 上 transaction 的延遲，也就是 client 端收到 transaction commit 的時間會變晚，另外相應的會增加資源的競爭，因此需評估最好的設置。</p><p>補充：在有 Group Commit 之後，sync_binlog 的單位指的是 Group 而不是 Transaction，例如：sync_binlog = 1000，表示的不是每 1000 個 Transaction 就 sync binlog，而是每 1000 個 Group 才 sync binlog。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_group_commit_sync_no_delay_count target=_blank rel=noopener>binlog_group_commit_sync_no_delay_count</a></p><p><img src=/p/mysql-mts/binlog-group-commit-sync-no-delay-count.png width=575 height=285 srcset="/p/mysql-mts/binlog-group-commit-sync-no-delay-count_hu_31a81363cebe4293.png 480w, /p/mysql-mts/binlog-group-commit-sync-no-delay-count_hu_4454de47c2d58f5c.png 1024w" loading=lazy class=gallery-image data-flex-grow=201 data-flex-basis=484px></p><p>在 Group commit 中等待的 N 個 Transaction 後就不等待 binlog_group_commit_sync_delay 設置的時間直接開始 sync binlog。</p><p>當 binlog_group_commit_sync_delay = 0 ，此參數無效。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_slave_preserve_commit_order target=_blank rel=noopener>slave_preserve_commit_order</a> (5.7 ~ 8.0.25)、<a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-replica.html#sysvar_replica_preserve_commit_order target=_blank rel=noopener>replica_preserve_commit_order</a> (8.0.26 ~)</p><p><img src=/p/mysql-mts/slave-preserve-commit-order.png width=576 height=281 srcset="/p/mysql-mts/slave-preserve-commit-order_hu_850124080f73874.png 480w, /p/mysql-mts/slave-preserve-commit-order_hu_59b2b2377aa92ade.png 1024w" loading=lazy class=gallery-image data-flex-grow=204 data-flex-basis=491px></p><p>只有當 slave_parallel_type = LOGICAL_CLOCK 且 log-slave-updates 開啟時才能設置。</p><p>當設置為 0 或 OFF 時，在 Replica 上的讀取操作無法滿足 <code>Causal Consistency</code> ，在 Source 和 Replica 上 Transaction 在 binlog 中可能有不同的寫入順序，另外在檢查 Replica 上最近執行的 Transaction 無法保證對應到 Source 上該 Transaction 位置之前的 Transaction 都已經執行完畢。</p><p>設置為 1 或 ON 確保 Transaction 在執行時按照在 relay log 中的順序，這可以讓 Master 和 Replica 有相同的 Transaction history log，也就是符合 <code>Causal Consistency</code>。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_dependency_tracking target=_blank rel=noopener>binlog_transaction_dependency_tracking</a> (5.7.22 ~)</p><p><img src=/p/mysql-mts/binlog-transaction-dependency-tracking.png width=575 height=298 srcset="/p/mysql-mts/binlog-transaction-dependency-tracking_hu_706dc27ebec643cc.png 480w, /p/mysql-mts/binlog-transaction-dependency-tracking_hu_3fd8ed4baf5eeb2c.png 1024w" loading=lazy class=gallery-image data-flex-grow=192 data-flex-basis=463px></p><p>指定 Source 依據什麼方式來生成 Transaction 之間的依賴關係寫入 binlog，協助 Replica 確定那些 Transaction 能夠並行執行。</p><p>必須設置 replica_parallel_type 為 LOGICAL_CLOCK。</p><p>有以下三種值：</p><ul><li>COMMIT_ORDER：使用 5.7 Group commit 的方式判斷。</li><li>WRITESET：使用 WriteSet 的方式判斷 Transaction 是否有衝突。</li><li>WRITESET_SESSION：WRITESET 的基礎上保證同一個 session 內的 Transaction 不可並行。</li></ul></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_transaction_dependency_history_size target=_blank rel=noopener>binlog_transaction_dependency_history_size</a> (8.0 ~)</p><p><img src=/p/mysql-mts/binlog-transaction-dependency-history.png width=573 height=281 srcset="/p/mysql-mts/binlog-transaction-dependency-history_hu_1415df38253b7d55.png 480w, /p/mysql-mts/binlog-transaction-dependency-history_hu_fdc1f13a3e149985.png 1024w" loading=lazy class=gallery-image data-flex-grow=203 data-flex-basis=489px></p><p>WriteSet 會判斷 Transaction 之間是否衝突，因此需要將 commit 的 Transaction 修改的行 hash 後暫時保存在內存。</p><p>此參數用來設定儲存的 hash 上限，超過此上限會清除先前的歷史紀錄。</p><p>若 Source 性能有餘裕可以考慮提升此參數，進一步提高 Replica 的並行度。</p></li><li><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_transaction_write_set_extraction target=_blank rel=noopener>transaction_write_set_extraction</a></p><p><img src=/p/mysql-mts/transaction-write-set-extraction.png width=573 height=324 srcset="/p/mysql-mts/transaction-write-set-extraction_hu_788d0ffa134a8fe0.png 480w, /p/mysql-mts/transaction-write-set-extraction_hu_ee47aa4a08fca84b.png 1024w" loading=lazy class=gallery-image data-flex-grow=176 data-flex-basis=424px></p><p>設定 WriteSet 使用的 Hash 演算法。</p><p>MySQL 5.7 預設為 OFF，MySQL 8.0.26 後棄用，一般不用特別調整。</p></li></ul><h2 id=官方測試數據>官方測試數據</h2><p>以下為官方使用SYSBENCH進行壓測的圖表，可以觀察到：</p><ul><li>在 Source 低並行率的情況，WRITESET 的機制下 Replica 仍舊能夠有良好的並行率。</li><li>當 Source 並行率越高，COMMIT_ORDER 和 WriteSet 差距會縮小。</li></ul><p><img src=/p/mysql-mts/official-1.png width=638 height=369 srcset="/p/mysql-mts/official-1_hu_3b00e87c44e3ed28.png 480w, /p/mysql-mts/official-1_hu_d342e907d68b98f.png 1024w" loading=lazy class=gallery-image data-flex-grow=172 data-flex-basis=414px></p><p><img src=/p/mysql-mts/official-2.png width=634 height=364 srcset="/p/mysql-mts/official-2_hu_197b19f1142a4d1.png 480w, /p/mysql-mts/official-2_hu_e3dc63fec2c378c2.png 1024w" loading=lazy class=gallery-image data-flex-grow=174 data-flex-basis=418px></p><p><img src=/p/mysql-mts/official-3.png width=630 height=339 srcset="/p/mysql-mts/official-3_hu_67c48b3d5247c90e.png 480w, /p/mysql-mts/official-3_hu_44f1e486e24843f1.png 1024w" loading=lazy class=gallery-image data-flex-grow=185 data-flex-basis=446px></p><h2 id=親自測試>親自測試</h2><p>環境：Mysql 8.0.12，測試前stop slave，待sysbench跑完後在start slave</p><p>確認在performance_schema中，MTS相關的統計ENABLED皆有開啟(YES)</p><p><img src=/p/mysql-mts/setup-instruments.png width=618 height=113 srcset="/p/mysql-mts/setup-instruments_hu_46e9f6547d7d3976.png 480w, /p/mysql-mts/setup-instruments_hu_2e44d025aede9c80.png 1024w" loading=lazy class=gallery-image data-flex-grow=546 data-flex-basis=1312px></p><p>(*啟用或禁用transaction event的收集)</p><p><img src=/p/mysql-mts/setup-consumers.png width=604 height=141 srcset="/p/mysql-mts/setup-consumers_hu_9796bfda0a9b4b1.png 480w, /p/mysql-mts/setup-consumers_hu_b014b47d6902f199.png 1024w" loading=lazy class=gallery-image data-flex-grow=428 data-flex-basis=1028px></p><p>(分別為當前的transaction event，每個線程最近的transaction event，global(跨線程)最近的transaction event)</p><p>查詢MTS並行度的語法</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>select thread_id,count_star
</span></span><span class=line><span class=cl>from events_transactions_summary_by_thread_by_event_name
</span></span><span class=line><span class=cl>where thread_id in (
</span></span><span class=line><span class=cl>select thread_id
</span></span><span class=line><span class=cl>from replication_applier_status_by_worker
</span></span><span class=line><span class=cl>);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>OR
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>USE test;
</span></span><span class=line><span class=cl>CREATE VIEW rep_thread_count AS SELECT a.THREAD_ID AS THREAD_ID,a.COUNT_STAR AS COUNT_STAR
</span></span><span class=line><span class=cl>FROM performance_schema.events_transactions_summary_by_thread_by_event_name a
</span></span><span class=line><span class=cl>WHERE a.THREAD_ID in (SELECT b.THREAD_ID FROM performance_schema.replication_applier_status_by_worker b);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>SELECT SUM(COUNT_STAR) FROM rep_thread_count INTO @total;
</span></span><span class=line><span class=cl>SELECT 100*(COUNT_STAR/@total) AS thread_usage FROM rep_thread_count;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#replication_applier_status_by_worker可以查看replication各個線程的運作狀況
</span></span><span class=line><span class=cl>#events_transactions_summary_by_thread_by_event_name彙總的每個線程的事件名稱，包含已關閉線程
</span></span><span class=line><span class=cl>#透過replication...table找出正在運作的線程再到event...table找到他們的count_star(執行的transaction數量)
</span></span></code></pre></td></tr></table></div></div><p>首次壓測以Threads 1 進行10分鐘壓測</p><p><img src=/p/mysql-mts/sysbench-thread-1.png width=735 height=228 srcset="/p/mysql-mts/sysbench-thread-1_hu_bf23ccaac58c4d23.png 480w, /p/mysql-mts/sysbench-thread-1_hu_f1aa00859d09101b.png 1024w" loading=lazy class=gallery-image data-flex-grow=322 data-flex-basis=773px></p><p>在commit_order下測試(即MySQL 5.7使用)</p><p><img src=/p/mysql-mts/sysbench-commit-order-57-1.png width=552 height=113 srcset="/p/mysql-mts/sysbench-commit-order-57-1_hu_fed257d9318fbb9a.png 480w, /p/mysql-mts/sysbench-commit-order-57-1_hu_a778a8e65d8111cf.png 1024w" loading=lazy class=gallery-image data-flex-grow=488 data-flex-basis=1172px></p><p><img src=/p/mysql-mts/sysbench-thread-1-result.png width=224 height=135 srcset="/p/mysql-mts/sysbench-thread-1-result_hu_f96a92895ed00c07.png 480w, /p/mysql-mts/sysbench-thread-1-result_hu_d62c32fadcef5314.png 1024w" loading=lazy alt="commit_order 並行效率" class=gallery-image data-flex-grow=165 data-flex-basis=398px></p><p>在WriteSet下測試(MySQL 8.0新方案)</p><p><img src=/p/mysql-mts/sysbench-writeSet-80-1.png width=557 height=114 srcset="/p/mysql-mts/sysbench-writeSet-80-1_hu_56bd1ec0d29b6c37.png 480w, /p/mysql-mts/sysbench-writeSet-80-1_hu_82258c7637565e83.png 1024w" loading=lazy class=gallery-image data-flex-grow=488 data-flex-basis=1172px></p><p><img src=/p/mysql-mts/sysbench-writeSet-thread1-result.png width=231 height=141 srcset="/p/mysql-mts/sysbench-writeSet-thread1-result_hu_301b577cfa94eab4.png 480w, /p/mysql-mts/sysbench-writeSet-thread1-result_hu_67050ade438aac2b.png 1024w" loading=lazy alt="writeSet 並行效率" class=gallery-image data-flex-grow=163 data-flex-basis=393px></p><p>接著試試看Threads 128進行10分鐘壓測</p><p><img src=/p/mysql-mts/sysbench-thread-128.png width=720 height=229 srcset="/p/mysql-mts/sysbench-thread-128_hu_f8f6eac7cf91aa4.png 480w, /p/mysql-mts/sysbench-thread-128_hu_dc7f8ce4a44b7b75.png 1024w" loading=lazy class=gallery-image data-flex-grow=314 data-flex-basis=754px></p><p>在commit_order下測試(即MySQL 5.7使用)</p><p><img src=/p/mysql-mts/sysbench-commit-order-57-1.png width=552 height=113 srcset="/p/mysql-mts/sysbench-commit-order-57-1_hu_fed257d9318fbb9a.png 480w, /p/mysql-mts/sysbench-commit-order-57-1_hu_a778a8e65d8111cf.png 1024w" loading=lazy class=gallery-image data-flex-grow=488 data-flex-basis=1172px></p><p><img src=/p/mysql-mts/sysbench-thread-128-commit-order-result.png width=211 height=114 srcset="/p/mysql-mts/sysbench-thread-128-commit-order-result_hu_e0649ddfe29e882f.png 480w, /p/mysql-mts/sysbench-thread-128-commit-order-result_hu_546283d58a856a6e.png 1024w" loading=lazy alt="commit_order 並行效率" class=gallery-image data-flex-grow=185 data-flex-basis=444px></p><p>在WriteSet下測試(MySQL 8.0新方案)</p><p><img src=/p/mysql-mts/sysbench-writeSet-80-1.png width=557 height=114 srcset="/p/mysql-mts/sysbench-writeSet-80-1_hu_56bd1ec0d29b6c37.png 480w, /p/mysql-mts/sysbench-writeSet-80-1_hu_82258c7637565e83.png 1024w" loading=lazy class=gallery-image data-flex-grow=488 data-flex-basis=1172px></p><p><img src=/p/mysql-mts/sysbench-thread-128-writeSet-result.png width=221 height=142 srcset="/p/mysql-mts/sysbench-thread-128-writeSet-result_hu_34e16099ee1d33e6.png 480w, /p/mysql-mts/sysbench-thread-128-writeSet-result_hu_cd73732064be7b1b.png 1024w" loading=lazy alt="writeSet 並行效率" class=gallery-image data-flex-grow=155 data-flex-basis=373px></p><p>測試結果基本上和官方提供的差不多，主要是解決在Master低並行度的情況下，提高MTS的效率。</p><h2 id=log>LOG</h2><p>當開啟 MTS 且 log_error_verbosity = 3 (NOTE) 時，會在</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>2023-01-30T03:08:36.440821Z 6 [Note] [MY-010559] [Repl] Multi-threaded slave statistics for channel &#39;&#39;: seconds elapsed = 277; events assigned = 20795393; worker queues filled over overrun level = 0; waited due a Worker queue full = 0; waited due the total size = 0; waited at clock conflicts = 12923330700 waited (count) when Workers occupied = 0 waited when Workers occupied = 0
</span></span></code></pre></td></tr></table></div></div><h2 id=懶人包>懶人包</h2><h3 id=mysql-575721-參數設定>MySQL 5.7~5.7.21 參數設定</h3><ul><li><p>Source (Master)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 以下非必須，依據實際情況評估調整
</span></span><span class=line><span class=cl>binlog_group_commit_sync_delay = ?
</span></span><span class=line><span class=cl>binlog_group_commit_sync_no_delay_count = ?
</span></span></code></pre></td></tr></table></div></div></li><li><p>Replica (Slave)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 推薦調整
</span></span><span class=line><span class=cl>slave_parallel_workers = ?
</span></span><span class=line><span class=cl>slave_parallel_type = LOGICAL_CLOCK
</span></span><span class=line><span class=cl>slave_preserve_commit_order = ON
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=mysql-572280xx-參數設定>MySQL 5.7.22~8.0.XX 參數設定</h3><ul><li><p>Source (Master)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 推薦調整
</span></span><span class=line><span class=cl>binlog_transaction_dependency_tracking = WRITESET_SESSION
</span></span><span class=line><span class=cl>transaction_write_set_extraction = XXHASH64
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 以下依據實際情況評估調整
</span></span><span class=line><span class=cl># 優先調整
</span></span><span class=line><span class=cl>binlog_transaction_dependency_history_size = ?
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 調整優先度低，因為退化回 commit order 時才有效，情境為：
</span></span><span class=line><span class=cl># 1. 沒有 pk 或 uk
</span></span><span class=line><span class=cl># 2. DDL 語句
</span></span><span class=line><span class=cl># 3. Transaction 的更新包含 FK
</span></span><span class=line><span class=cl># 4. history 剛被清空
</span></span><span class=line><span class=cl># 5. 同一個 session 的 Transaction (WRITESET_SESSION)
</span></span><span class=line><span class=cl>binlog_group_commit_sync_delay = ?
</span></span><span class=line><span class=cl>binlog_group_commit_sync_no_delay_count = ?
</span></span></code></pre></td></tr></table></div></div></li><li><p>Replica (Slave)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 推薦調整
</span></span><span class=line><span class=cl>slave_parallel_workers = ?
</span></span><span class=line><span class=cl>slave_parallel_type = LOGICAL_CLOCK
</span></span><span class=line><span class=cl>slave_preserve_commit_order = ON
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=mts-效率確認>MTS 效率確認</h3><p>調整後可以使用以下語法查看調整後 MTS 並行的效率，理想的情況下同一個 channel 的每個 sql thread 的 count_star 應該差不多：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- mysql 5.7 需先開啟以下設定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>update</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>setup_consumers</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>enabled</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;yes&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;events_transactions%&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>update</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>setup_instruments</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>enabled</span><span class=o>=</span><span class=w> </span><span class=s1>&#39;yes&#39;</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;transaction&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- mysql 5.7 需先開啟以上設定
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>replication_status</span><span class=p>.</span><span class=n>CHANNEL_NAME</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>replication_status</span><span class=p>.</span><span class=n>thread_id</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>enent_summary</span><span class=p>.</span><span class=n>count_star</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>events_transactions_summary_by_thread_by_event_name</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>enent_summary</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>INNER</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>performance_schema</span><span class=p>.</span><span class=n>replication_applier_status_by_worker</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>replication_status</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>USING</span><span class=p>(</span><span class=n>thread_id</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=bug>BUG</h2><ul><li><p><a class=link href="https://bugs.mysql.com/bug.php?id=103636" target=_blank rel=noopener>MySQL Bugs: #103636: Slave hangs with slave_preserve_commit_order On</a></p><p>說明：當 replica 設置了 replica_preserve_commit_order = 1 在高負載下長時間使用時，可能會用完 commit order sequence tickets 導致 applier 掛起 (hang) 並且無期限的持續等待 commit order queue。</p><p>影響版本：MySQL 8.0.28 之前</p><p>修復版本： MySQL 8.0.28</p><p>github 資訊：<a class=link href=https://github.com/mysql/mysql-server/commit/f6bb5e7cc5e57f44c881a3f63ee507102c3e398d target=_blank rel=noopener>BUG#32891221 REPLICA HANGS WITH REPLICA_PRESERVE_COMMIT_ORDER ON · mysql/mysql-server@f6bb5e7 · GitHub</a></p></li></ul><h1 id=參考>參考</h1><p><a class=link href=http://mysql.taobao.org/monthly/2018/06/04/ target=_blank rel=noopener>MySQL · 特性分析 · 8.0 WriteSet 并行复制</a></p><p><a class=link href=https://www.cnblogs.com/VicLiu/p/14653400.html target=_blank rel=noopener>速度提升5~10倍，基于WRITESET的MySQL并行复制 #M1013# - VicLW - 博客园 (cnblogs.com)</a></p><p><a class=link href=https://blog.csdn.net/joy0921/article/details/80130768 target=_blank rel=noopener>MySQL 5.7并行复制中并行的真正含义_仲培艺的博客-CSDN博客</a></p><p><a class=link href=http://mysql.taobao.org/monthly/2017/12/03/ target=_blank rel=noopener>MySQL · 特性分析 · LOGICAL_CLOCK 并行复制原理及实现分析 (taobao.org)</a></p><p><a class=link href="https://dev.mysql.com/worklog/task/?id=6314" target=_blank rel=noopener>MySQL :: WL#6314: MTS: Prepared transactions slave parallel applier</a></p><p><a class=link href="https://dev.mysql.com/worklog/task/?id=7165" target=_blank rel=noopener>MySQL :: WL#7165: MTS: Optimizing MTS scheduling by increasing the parallelization window on master</a></p><p><a class=link href=https://juejin.cn/post/6949470247673921567 target=_blank rel=noopener>MySQL-组提交与并行复制 - 掘金 (juejin.cn)</a></p><p><a class=link href="https://dev.mysql.com/worklog/task/?id=9556" target=_blank rel=noopener>MySQL :: WL#9556: Writeset-based MTS dependency tracking on master</a></p><p><a class=link href=http://mysql.taobao.org/monthly/2017/08/01/ target=_blank rel=noopener>MySQL · 引擎特性 · Group Replication内核解析 (taobao.org)</a></p><p><a class=link href=https://opensource.actionsky.com/20190902-mysql/ target=_blank rel=noopener>社区投稿 | 基于 WRITESET 的并行复制方式 (actionsky.com)</a></p><p><a class=link href=https://dev.mysql.com/blog-archive/improving-the-parallel-applier-with-writeset-based-dependency-tracking/ target=_blank rel=noopener>MySQL :: Improving the Parallel Applier with Writeset-based Dependency Tracking</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/61336729 target=_blank rel=noopener>MySQL Group Replication冲突检测机制再剖析 - 知乎 (zhihu.com)</a></p><p><a class=link href=https://zhuanlan.zhihu.com/p/71913226 target=_blank rel=noopener>深入浅析一致性模型之Causal Consistency - 知乎 (zhihu.com)</a></p><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/replication-features-transaction-inconsistencies.html target=_blank rel=noopener>MySQL :: MySQL 8.0 Reference Manual :: 17.5.1.34 Replication and Transaction Inconsistencies</a></p><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/start-replica.html target=_blank rel=noopener>MySQL :: MySQL 8.0 Reference Manual :: 13.4.2.8 START REPLICA Statement</a></p><p><a class=link href=https://dev.mysql.com/doc/refman/8.0/en/show-replica-status.html target=_blank rel=noopener>MySQL :: MySQL 8.0 Reference Manual :: 13.7.7.35 SHOW REPLICA STATUS Statement</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/replication/>Replication</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>相關文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/mysql-gtid/><div class=article-details><h2 class=article-title>GTID</h2></div></a></article><article><a href=/p/mysql-replication-delay-observation-improve/><div class=article-details><h2 class=article-title>MySQL8.0 對於 replication delay 觀測改進</h2></div></a></article><article><a href=/p/mysql-implicit-lock/><div class=article-details><h2 class=article-title>隱式鎖</h2></div></a></article><article><a href=/p/mysql-group-commit/><div class=article-details><h2 class=article-title>Group Commit</h2></div></a></article><article><a href=/p/mysql-fulltext-index/><div class=article-details><h2 class=article-title>MySQL FullText Index(全文檢索)</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//小小 DBA 個人筆記.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 FuweaY</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 建立<br>主題 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 設計</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>